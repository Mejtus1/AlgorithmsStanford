Algorithms and Data-Structures

algorithms = operations on different data structures and the sets of instructions to executing them 
- depending on what data structure we are using to store data, that we are performing algorithm on our algorithms
may work differently, or completly different algorithm for solving the same problem, because of data structure we are using 

// -------------------------------------------------------------------------------------------------------------------------
Arrays 
[5, 2, 300, 20] = array of integers
["yeah", "ouch", "haha"] = array of strings 

Example code of Arrays 
int sampleArray[5] = {2, 4, 6, 8, 100}
sampleArray[0] = 20; 
sampleArray[1] = -5;
{20, -5, 6, 8, 100}
- in C we cannot add another space for array because of how memory on computer works

Memory 
Memory (RAM) = data is not permanent 
Storage = data is permanent 
- when we work on program in our memory, it needs to be stored in storage to be there after computer shuts down
Why dont we use just storage ? 
- we use memory RAM, because it is temporary and faster
- retrieving everything from storage will be inneficient and slow
Applications 
- are stored in storage, because after shut down our OS they are still there
Lounching Google chrome
- is loaded into memory RAM, because it is faster there
- running too much 

Memory and programming 
- we assign: 
int a = 1;
- if we turn off our computer, this will dissapear because it is only stored in memory 
- each int if is stored in computer it is stored as 32 bit value:
1 = 00000000000000000000000000000001
2 = 00000000000000000000000000000010
3 = 00000000000000000000000000000011

byte 
- small unit of data consisting of bits 
- 1 byte = 8 bits 

Memory 
-----------------------------------------------------
|   |   |   |   |   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |   |   |   |   |
-----------------------------------------------------
 120 121 123 124 125 126 127 128 129 130 131 132 133 

inta a = 1; 
= 00000000000000000000000000000001 (in memory)
4 parts of memory are reserved for this int variable with value 
-----------------------------------------------------
| 4 | b | y | t |   |   |   |   |   |   |   |   |   |
| e | s | * | * |   |   |   |   |   |   |   |   |   |
-----------------------------------------------------
 120 121 123 124 125 126 127 128 129 130 131 132 133 

- after assigning 2 variables in same block, it will be assigned right after first one 
int a = 1; 00000000000000000000000000000001
int b = 3; 00000000000000000000000000000010
-----------------------------------------------------
|1st| v | a | r |2nd| v | a | r |   |   |   |   |   |
| i | a | b |le | i | a | b |le |   |   |   |   |   |
-----------------------------------------------------
 120 121 123 124 125 126 127 128 129 130 131 132 133 

- another data types can be asigned into memory with their own values 
- examples include integers (5, 6, -24), decimals (2.3, 5.7, -2.8) characters ('a', 'w')

---------------------------------------------------------------------------------
|1st| v | a | r | * |1st|   | * | * |2nd|   | * | * |3rd|   | * |2nd| v | a | r |
| i | a | b |le | * |arr|ay | * | * |arr|ay | * | * |arr|ay | * | i | a | b |le |
---------------------------------------------------------------------------------
 120 121 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140
int a = 1; 
int sampleArray[3] = {5, 3, 20};
sampleArray[0] = {5}; = 4 bytes
sampleArray[1] = {3}; = 4 bytes
sampleArray[2] = {20}; = 4 bytes
int b = 3; 

- after allocating 12 bytes for array in memory and assigning new variable, new values to the array
cannot be added without dynamically moving from old memory space to new, bigger one whole arrau
plus additional space for 2 new integers 

// -------------------------------------------------------------------------------------------------------------------------
CLASSES AND OBJECTS
- attributes, methods, constructors 
- classes and objects are one of most fundamental topics when it comes to data structures and algorithms
- actual usecase is using it to represent bots with functions

bot Tom{
    function hello("Hello, I am TOM")
}

bot Jerry{
    function hello("Hey, I am Jerry")
}
- storing sets of information in each of bots 
- adding properties and functionalities to these bots 
- also adding variables 
bot Tom{
    function hello("Hello, I am TOM")
    var int weight: 30 
    var str name: "TOM"
}

OBJECT 
- is collection of properties, variables and functions 
- object represents thing that it is assigned, with different functions and properties
bot Tom{
    function hello("Hello, I am TOM")
    var int weight: 30 
    var str name: "TOM"
}
- once object is created, we can put him inside variable that represents that object
- so we can use it or call it inside another function 

r1 = bot Tom {
    function introduceSelf("Hello, I am TOM")
    var int weight: 30 
    var str name: "TOM"
}

r2 = bot Jerry {
    function introduceSelf("Hello, my name is Jerry")
    var int weight: 40
    var str name: "Jerry"
    var str color: "blue"
}
- we have 2 objects and they have common function and attributes 
- is there a way to organize this ?:
- yes = classes

CLASS 
- class is like a blueprint for our bots 

class {
    name:
    color:
    weight: 
    hello()
}
- values are not definet yet, it doesnt refer to any specific bot in our case
- it points just to our category of bots  
- when we define a class we need to give it a name

class Robot {
    name:
    color:
    weight: 
    hello()
}

introduceSelf(
    "My name is " + name
);
- function, with build in functionality in java 
- example of CLASS code in java: 

Robot r1 = new Robot();
r1.name = "Tom";
r1.color = "red";
r1.weight = 30;

Robot r2 = new Robot();
r2.name = "Jerry";
r2.color = "blue";
r2.weight = 40;

r1.introduceSelf()
r2.introduceSelf()
- run this function introduceSelf() on this object r1, r2
- prints our for r1.introduceSelf() ["Hello, my name is TOM"]
- prints our for r2.introduceSelf() ["Hello, my name is Jerry"]

HOW IS THIS CLASS DEFINED ? 
- these are instant variables of class Robot 
class Robot {
    String name;
    String color; 
    int weight; 

    void introduceSelf() {
        System.out.printIn(
           "My name is " + this.name);
    }
}
 - when this is called it happens like 
 1. class introduceSelf is called
 2. System.out.printIn is called with output: "My name is "
 3.  + this.name = this refers to r1 or r2 .name

 - instead of creating object everytime from scratch and write the stame data 
 - we can use CONSTRUCTOR 

Constructor 
- function, that allows to create an object from a class

Robot(String n, String c, int w) {
 this.name = n;
 this.color = c;
 this.weight = w;
}
- when this new constructor is defined, previous bots are deleted
- now we can define new robot using our constructor 
Robot r1 = new Robot("Tom", "red", 30);
Robot r2 = new Robot("Jerry", "blue", 40);
- these arguments are going to be passed down to the construcor

class Person {
 name:
 personality: 
 isSitting:
 robotOwned: 

 sitDown()
 standUp()
}

p1 = {
 name: "Alice"
 personality: "aggressive"
 isSitting: false
 robotOwned: r2
}

p2 = {
 name: "Becky"
 personality: "talkative"
 isSitting: true
 robotOwned: r1
}

- how to interact set of objects and make them interact with eacg other 
- we are going to interact with previous objects = bots 
- robotOwned attribute expresses realitionships with differenet classes and objcets

Example of whole code in java
<TestRobotAndPerson.java>
--------------------------------|
Robot r1 = new Robot();         |
r1.name = "Tom";                |
r1.color = "red";               |
r1.weight = 30;                 |
                                |
Robot r2 = new Robot();         |
r2.name = "Jerry";              |
r2.color = "blue";              |
r2.weight = 40;                 |
                                |
r1.introduceSelf()              |
r2.introduceSelf()              |
                                |
Person p1 = new Person("Alice", |
 "aggressive", false);          |
Person p2 = new Person("Becky", |
 "talkative", true);            |
                                |
p1.robotOwned = r2;             |
p2.robotOwned = r1;             |
                                |
p1.robotOwned.introduceSelf();  |
p2.robotOwned.introduceSelf();  |
--------------------------------|
-----------------------------------|
class Person {                     |
    Strong name;                   |
    String personality;            |
    boolean isSitting;             |
    Robot robotOwned;              |
                                   |
    Person(String n, String p,     | 
                boolean i) {       |
        this.name = n;             |
        this.personality = p;      |
        this,isSitting = i;        |
        }                          |
                                   |
    void sitDown() {               |
        this.isSitting = true; }   |
    void standUp() {               |
        this.isSitting = false; }  |
}                                  |
-----------------------------------|
// -------------------------------------------------------------------------------------------------------------------------
