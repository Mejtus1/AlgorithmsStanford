// --------------------------------------------------------------------------------------------------------
1. Introduction to Algorithms 
- algorithm is a step by step procedure of solving computational problem 
- program is also a step by step procedure of solving a problem 
- SDLC = software development lifecycle 
Algorithm                     Program 
Deisgn phase of SDLC          Implementation phase of SDLC 
Domain knowledge              Programmer (programmer can also have domain knowledge)
any language                  programming language 
(or mathematical notation)
Hardware/Software/OS          H/S/OS dependent 
idependent 
Analyze                       Testing 

// --------------------------------------------------------------------------------------------------------
1.1 Priori analysis, Postpriori testing 

Priori Analysis             Posteriori Testing
1. Algorithm                1. Program
2. Independent Language     2. Language dependent 
3. Hardware Independent     3. Hardware dependent 
4. Time & Space Function    4. Watch time & Bytes 

// --------------------------------------------------------------------------------------------------------
1.2 Characteristics of Algorithm 

Input (algorithm must take some input, 0 or more)
Output (algorithm must generate at least one ouput)
Definitness (Every statement should be ambigious, there cannot be statement that cannot be solved)
( - we cannot use for example value root -1 because we dont know its output too, program cannot either)
Finitness (solution must exist)
Effectivness (there shouldnt be any unnecesarry statements)

// --------------------------------------------------------------------------------------------------------
1.3 How to write an Algorithm 
- all algorithms are procedures to solve a problem 
Algorithm Swap(a,b)
{ "begin" 
    temp = a;
    a = b;
    b = temp;
} "end" 

How to analyze algorithm 
main criteria: 
1. Time (how much time is it taking)
- algorithm should be time efficient 
2. space (how much memory, space it will consume)
another criteria: 
3. data transfer, network consumption (because today everything is cloud-based)
4. Power comsumption (because of Mobile phones, Ipads and other mobile devices)
5. CPU register is algorithm consuming (how many resistors)

- all criteria depent on project
- every step in the algorithm takes 1 unit of time
{ "begin" 
    temp = a; ------ 1 
    a = b;    ------ 1 
    b = temp; ------ 1 
} "end" 
f(n) = 3 
- when we assign our statement it also is one unit of time 
x = 5 a + 6 b ------- 1 unit of time 

space calculation: 
a ------- 1
b ------- 1 
temp ----1 
S(n) = 3 words = words, because when we convert it into program we dont know if it is going to be 
int, float, double type 

// --------------------------------------------------------------------------------------------------------
1.4 Frequency control method

Addition array 
- we have array of size 5 
A [8 3 9 7 2]
A = array 
- lets analyze time of this algorithm 
- time of the algorithm can be known by assinging one unit of time for each statement 
- if each statement is repeating for some number of times , the frequency of statement 
will calculate and we will find the time taken by that algorithm 

Algorithm Sum(A,n)
{
  s=0 ----------------- 1 unit of time 
  for(i=0; i<n; i++) -- n+1                (i=0; i<n; i++)
    S=S+A[i] ---------- n                    1    n+1   n 
}                                           when n is 5
return s; ------------- 1                   i = 0, 0 < n 
                                            i = 1, 1 < n 
time complexity                             i = 2, 2 < n 
f(n) = 2n + 3 (we sum up numbers and n)     i = 3, 3 < n 
O(n)                                        i = 4, 4 < n 
                                            i = 5, 5 < n NOT 
space complexity                            which is n + 1 
- what are the variables used in here ? 
A --- n 
n --- 1 
s --- 1 
i --- 1 
S(n) = n + 3 
O(n)           (degree of this polynomial = O(n) = order of n)

----------------------------
Find the sum of two matrices 
matrices = 2 dimensional arrays nxn in this example 

Algorithm Add (A,B,n)
{
  for(i=0; i<n; i++) ------------ n + 1          (for loop time complexity)
  {                                              (whatever is inside this loop will execute x times)
    for(j=0; j<n; j++) ---------- n * (n + 1)    (we add n+1 times n because this is another for loop) 
    {
      c[i,j] = A[i,j] + B[i,j]; - n * n           (whatever is inside last one, will execute n times)
    }
  }
}

time complexity 
(n + 1 + n * (n + 1) + n * n)
f(n) = 2n2power + 2n + 1
O(n2power)
- we write n2squared only because of highest degree of polynomial

space complexity 
- what are the variables here, we are having: 
A -- n2power (matrices)
B -- n2power (matrices)
C -- n2power (matrices)
n -- 1 (word)
i -- 1 (word)
j -- 1 (word)
--------
s(n) = n2squared + n2squared + n2squared + 1 + 1 + 1
S(n) = 3n2power + 3 
- what is the highest degree of polynomial
O(n2power)

------------------------------
Multiplication of two matrices

Algorithm Multiply(A,B,n)
{
  for(i=0; i<n; i++)                --------- n + 1 
  {
    for(j=0; j<n; j++)              --------- (n + 1) * n 
    {
      c[i,j]=0;                     --------- n * n 
      for(k=0; k<n; k++)            --------- (n + 1) * n * n
      {
        c[i,j]=c[i,j]+A[i,k]*B[k,j]; -------- n * n * n
      }
    }
  }
}
- when we have first loop which is n + 1, we already know each statement will run at least for n times
- we have second for loop, we can assume every other statement will be n times 
- third loop means another n+1 on loop and last statement x times more

time complexity: 
= n + 1 + (n + 1) * n + n * n + (n + 1) * n * n + n * n * n
= n + 1 + n2squared + 1n + n2squared + 2n3power + 1n2squared 
= 3n2squared + 2n3power + 2n + 1  
      {
f(n) = 3n2squared + 2n3power + 2n + 1
- because of highest degree of polynomial we have n3power 
O(n3power)

space comlexity: 
A ---- n2squared 
B ---- n2squared
C ---- n2squared
n ---- 1 word 
j ---- 1 word
k ---- 1 word
i ---- 1 word
S(n) = 3n2squared + 4 
O(n2squared)

// --------------------------------------------------------------------------------------------------------
1.5 Time Complexity #1 

- increasing loop 
for(i=0; i<n; i++) --- n + 1 
{
  stmt; -------------- n 
}
Time Complexity: O(n)

- decreasing loop 
for(i=n; i>0; i--) --- n + 1 
{
  stmt; -------------- n 
}
Time Complexity: O(n)

- increasing loop by 2 
for(i=1; i<n; i=i+2) (we can get rid of upper n+1)
{
  stmt; -------------- n/2  
}
- but since this is polynomial n/2, what is the highest degree ?
- the highest degree of polynomial is n 
- which means this is also: 
Time Complexity: O(n)

- nested loops one inside another 
for(i=0; i<n; i++)    ----- n + 1 
{
  for(j=0; j<n; j++)  ----- (n + 1) x n 
  {
    stmt;             ----- n x n 
  }
}
Time complexity: O(n2squared)

- nested for loops one inside another with j<i in second for loop 
for(i=0; i<n; i++)    
{                           ////////////////////////
  for(j=0; j<i; j++)        |   i   |  j  | n time | 
  {                         |-------|-----|--------|  
    stmt; ------------------|   0   |  0X |    0   |
  }                         |-------|-----|--------|  
}                           |   1   | 0,1X|    1   |
1 + 2 + 3 + .... n =        |-------|-----|--------|
  n ( n + 1 )               |   2   |01,2X|    2   |
= -----------               |-------|-----|--------|
       2                    |   3   |0,1,2 3X| 3   |
f(n) = n2squared + 1 / 2    ////////////////////////          
- what is highest degree of polynomial ? 
O(n2squared)

- for loop where with P<=n 
P=0
for(i=1; P<=n; i++)
{
  P=P+i;
}
////////////////////////
|   i   |    P    |
|-------|---------|
|   1   | 0+1=1   |    
|-------|---------|
|   0   | 1+2=3   |
|-------|---------|
|   0   | 1+2+3+4 | 
|-------|---------|
|   K   |    K    | - this loop is going to execute for K times 
|-------|---------|
////////////////////////
- we assume that P > n the loop is stopped 
- as long as P is smaller or equal to n, the loop will execute 
- since P = k(k+1)
            ------
               2
- the condition is k(k+1)
                   ------ > n 
                      2 
- biggest part of this polynomial is k2squared > n 
- so if we exchange k with n it will be k > order of n 
- this loop will execute for order of n times

// ------------------------------
1.5.2 Time Complexity Examples #2 

- for loop with *2 in i++ 
- we can blindly say this will not execute for n times 
for(i=1; i<n; i=i*2)
{
  stmt; 
}
- we dont know n, so we dont know how many times 
i = 1 
i = i*2 = 1*2 = 2 
i = 2 
i = 2*2 = 2squared
i = 2squared = 4 
i = 2squared*2 = 2 to 3 power
i = 2 to 3 power 
i = 2 to 3 power*2 = 2 to 4 power
i = 2 to 4 power
i = 2 to 4 power*2 = 2 to 5 power
..........
- this will execute for 2 for k times 
2k 
- our rule: i < n will terminate until i < n
- assume i >= n 
- since i = 2 to power k 
2 power k >= n 
2k = n 
k = logn (in base 2 fromat)
- the statement will execute for order of:
Time compelxity: log n 
O(log n) in base 2 

----------------------------
for loop i++ vs for loop i*2

for(i=1; i<n; i=i*2)
{
  stmt; 
}
i = i * 2 * 2 * 2 * 2 .... = n 
2kpower = n 
k = logn (2)

for(i=1; i<n; i++)
{
  stmt; 
}
i = i+i+i+i+i ..... = n 
k = n 

- if we have a loop where value of i is going to  be multiplied than it is going to be : 
log n 
for(i=1; i<n; i=i*2)
{
  stmt; 
}
- if our output from log is decimal or float value, so we need to know if we want ot have C format value
- suppose n value = 8, 
n = 8 then 
i = 1, 2, 4, 8X = loop stops 
- we have 3 times loop run 
log 8 = 3
log 2 to power of 3 = 3log2
- since we have log in base 2 we can get rid of 2 and we are left with 3 

n = 10 then
i = 1, 2, 4, 8, 16X = loop stops here
- if we have log10, 10 is not exact number for power of 2, so we wont get exact number 
- we will recieve decimal value 
log 10 = 3.2 (this should be taken as seal value)
- which will correspont with our runtime which is 4 

// --------------------------------------------------------------------------------------------------------
Time Complexity of While and IF 

- Pascal language Syntax
for i = 1 to n do step 2    (1, 3, 5, 7, ...)
{
    stmt;
}
while(condition)         do                      repeat
{                        {                       {
    stmt;                   stmt;                   stmt; 
}                        } while (condition)     } until(condition);

- do while will execute as long as the condition is true 
- repeat until will execute until the condition is false 

// --------
- piece of code using while loop 
i = 0;    -------- 1 
while(i<n) ------- n+1
{
    stmt; -------- n 
    i++;  -------- n 
}
f(n) = 3n+2 
O(n)

- same code in C language
for(i=0; i<n; i++) ----- 1 + n+1 + n
{
    stmt; -------------- n
}
f(n)=3n+2
f(n)=2n+1
O(n)

// ---------------------
a = 1; 
while(a < b)
{
    stmt; 
    a = a * 2; 
}

a/1 
1 * 2 = 2
2 * 2 = 2to2power
2to2power * 2 = 2to3power
= 2 to k power 
- we dont know how many times is this going to happen

Terminate
a >= b 
a = 2tokpower
2tokpower >= b 
2tokpower = b 
k = log b 
O(log n)

- same code using for loop is: 
for(a=1; a<b; a=a*2)
{
    stmt; 
}

// ---------------
i = n;
while(i>1)
{
    stmt;
    i=i/2;
}
- is same as: 
for(i=n;i>1;i=i/2)
{
    stmt; 
}

