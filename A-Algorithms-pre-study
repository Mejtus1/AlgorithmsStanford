// --------------------------------------------------------------------------------------------------------
1. Introduction to Algorithms 
- algorithm is a step by step procedure of solving computational problem 
- program is also a step by step procedure of solving a problem 
- SDLC = software development lifecycle 
Algorithm                     Program 
Deisgn phase of SDLC          Implementation phase of SDLC 
Domain knowledge              Programmer (programmer can also have domain knowledge)
any language                  programming language 
(or mathematical notation)
Hardware/Software/OS          H/S/OS dependent 
idependent 
Analyze                       Testing 

// --------------------------------------------------------------------------------------------------------
1.1 Priori analysis, Postpriori testing 

Priori Analysis             Posteriori Testing
1. Algorithm                1. Program
2. Independent Language     2. Language dependent 
3. Hardware Independent     3. Hardware dependent 
4. Time & Space Function    4. Watch time & Bytes 

// --------------------------------------------------------------------------------------------------------
1.2 Characteristics of Algorithm 

Input (algorithm must take some input, 0 or more)
Output (algorithm must generate at least one ouput)
Definitness (Every statement should be ambigious, there cannot be statement that cannot be solved)
( - we cannot use for example value root -1 because we dont know its output too, program cannot either)
Finitness (solution must exist)
Effectivness (there shouldnt be any unnecesarry statements)

// --------------------------------------------------------------------------------------------------------
1.3 How to write an Algorithm 
- all algorithms are procedures to solve a problem 
Algorithm Swap(a,b)
{ "begin" 
    temp = a;
    a = b;
    b = temp;
} "end" 

How to analyze algorithm 
main criteria: 
1. Time (how much time is it taking)
- algorithm should be time efficient 
2. space (how much memory, space it will consume)
another criteria: 
3. data transfer, network consumption (because today everything is cloud-based)
4. Power comsumption (because of Mobile phones, Ipads and other mobile devices)
5. CPU register is algorithm consuming (how many resistors)

- all criteria depent on project
- every step in the algorithm takes 1 unit of time
{ "begin" 
    temp = a; ------ 1 
    a = b;    ------ 1 
    b = temp; ------ 1 
} "end" 
f(n) = 3 
- when we assign our statement it also is one unit of time 
x = 5 a + 6 b ------- 1 unit of time 

space calculation: 
a ------- 1
b ------- 1 
temp ----1 
S(n) = 3 words = words, because when we convert it into program we dont know if it is going to be 
int, float, double type 

// --------------------------------------------------------------------------------------------------------
1.4 Frequency control method

Addition array 
- we have array of size 5 
A [8 3 9 7 2]
A = array 
- lets analyze time of this algorithm 
- time of the algorithm can be known by assinging one unit of time for each statement 
- if each statement is repeating for some number of times , the frequency of statement 
will calculate and we will find the time taken by that algorithm 

Algorithm Sum(A,n)
{
  s=0 ----------------- 1 unit of time 
  for(i=0; i<n; i++) -- n+1                (i=0; i<n; i++)
    S=S+A[i] ---------- n                    1    n+1   n 
}                                           when n is 5
return s; ------------- 1                   i = 0, 0 < n 
                                            i = 1, 1 < n 
time complexity                             i = 2, 2 < n 
f(n) = 2n + 3 (we sum up numbers and n)     i = 3, 3 < n 
O(n)                                        i = 4, 4 < n 
                                            i = 5, 5 < n NOT 
space complexity                            which is n + 1 
- what are the variables used in here ? 
A --- n 
n --- 1 
s --- 1 
i --- 1 
S(n) = n + 3 
O(n)           (degree of this polynomial = O(n) = order of n)

----------------------------
Find the sum of two matrices 
matrices = 2 dimensional arrays nxn in this example 

Algorithm Add (A,B,n)
{
  for(i=0; i<n; i++) ------------ n + 1          (for loop time complexity)
  {                                              (whatever is inside this loop will execute x times)
    for(j=0; j<n; j++) ---------- n * (n + 1)    (we add n+1 times n because this is another for loop) 
    {
      c[i,j] = A[i,j] + B[i,j]; - n * n           (whatever is inside last one, will execute n times)
    }
  }
}

time complexity 
(n + 1 + n * (n + 1) + n * n)
f(n) = 2n2power + 2n + 1
O(n2power)
- we write n2squared only because of highest degree of polynomial

space complexity 
- what are the variables here, we are having: 
A -- n2power (matrices)
B -- n2power (matrices)
C -- n2power (matrices)
n -- 1 (word)
i -- 1 (word)
j -- 1 (word)
--------
s(n) = n2squared + n2squared + n2squared + 1 + 1 + 1
S(n) = 3n2power + 3 
- what is the highest degree of polynomial
O(n2power)

------------------------------
Multiplication of two matrices

Algorithm Multiply(A,B,n)
{
  for(i=0; i<n; i++)                --------- n + 1 
  {
    for(j=0; j<n; j++)              --------- (n + 1) * n 
    {
      c[i,j]=0;                     --------- n * n 
      for(k=0; k<n; k++)            --------- (n + 1) * n * n
      {
        c[i,j]=c[i,j]+A[i,k]*B[k,j]; -------- n * n * n
      }
    }
  }
}
- when we have first loop which is n + 1, we already know each statement will run at least for n times
- we have second for loop, we can assume every other statement will be n times 
- third loop means another n+1 on loop and last statement x times more

time complexity: 
= n + 1 + (n + 1) * n + n * n + (n + 1) * n * n + n * n * n
= n + 1 + n2squared + 1n + n2squared + 2n3power + 1n2squared 
= 3n2squared + 2n3power + 2n + 1  
      {
f(n) = 3n2squared + 2n3power + 2n + 1
- because of highest degree of polynomial we have n3power 
O(n3power)

space comlexity: 
A ---- n2squared 
B ---- n2squared
C ---- n2squared
n ---- 1 word 
j ---- 1 word
k ---- 1 word
i ---- 1 word
S(n) = 3n2squared + 4 
O(n2squared)

// --------------------------------------------------------------------------------------------------------
1.5 Time Complexity #1 

- increasing loop 
for(i=0; i<n; i++) --- n + 1 
{
  stmt; -------------- n 
}
Time Complexity: O(n)

- decreasing loop 
for(i=n; i>0; i--) --- n + 1 
{
  stmt; -------------- n 
}
Time Complexity: O(n)

- increasing loop by 2 
for(i=1; i<n; i=i+2) (we can get rid of upper n+1)
{
  stmt; -------------- n/2  
}
- but since this is polynomial n/2, what is the highest degree ?
- the highest degree of polynomial is n 
- which means this is also: 
Time Complexity: O(n)

- nested loops one inside another 
for(i=0; i<n; i++)    ----- n + 1 
{
  for(j=0; j<n; j++)  ----- (n + 1) x n 
  {
    stmt;             ----- n x n 
  }
}
Time complexity: O(n2squared)

- nested for loops one inside another with j<i in second for loop 
for(i=0; i<n; i++)    
{                           ////////////////////////
  for(j=0; j<i; j++)        |   i   |  j  | n time | 
  {                         |-------|-----|--------|  
    stmt; ------------------|   0   |  0X |    0   |
  }                         |-------|-----|--------|  
}                           |   1   | 0,1X|    1   |
1 + 2 + 3 + .... n =        |-------|-----|--------|
  n ( n + 1 )               |   2   |01,2X|    2   |
= -----------               |-------|-----|--------|
       2                    |   3   |0,1,2 3X| 3   |
f(n) = n2squared + 1 / 2    ////////////////////////          
- what is highest degree of polynomial ? 
O(n2squared)

- for loop where with P<=n 
P=0
for(i=1; P<=n; i++)
{
  P=P+i;
}
////////////////////////
|   i   |    P    |
|-------|---------|
|   1   | 0+1=1   |    
|-------|---------|
|   0   | 1+2=3   |
|-------|---------|
|   0   | 1+2+3+4 | 
|-------|---------|
|   K   |    K    | - this loop is going to execute for K times 
|-------|---------|
////////////////////////
- we assume that P > n the loop is stopped 
- as long as P is smaller or equal to n, the loop will execute 
- since P = k(k+1)
            ------
               2
- the condition is k(k+1)
                   ------ > n 
                      2 
- biggest part of this polynomial is k2squared > n 
- so if we exchange k with n it will be k > order of n 
- this loop will execute for order of n times

// ------------------------------
1.5.2 Time Complexity Examples #2 

- for loop with *2 in i++ 
- we can blindly say this will not execute for n times 
for(i=1; i<n; i=i*2)
{
  stmt; 
}
- we dont know n, so we dont know how many times 
i = 1 
i = i*2 = 1*2 = 2 
i = 2 
i = 2*2 = 2squared
i = 2squared = 4 
i = 2squared*2 = 2 to 3 power
i = 2 to 3 power 
i = 2 to 3 power*2 = 2 to 4 power
i = 2 to 4 power
i = 2 to 4 power*2 = 2 to 5 power
..........
- this will execute for 2 for k times 
2k 
- our rule: i < n will terminate until i < n
- assume i >= n 
- since i = 2 to power k 
2 power k >= n 
2k = n 
k = logn (in base 2 fromat)
- the statement will execute for order of:
Time compelxity: log n 
O(log n) in base 2 

----------------------------
for loop i++ vs for loop i*2

for(i=1; i<n; i=i*2)
{
  stmt; 
}
i = i * 2 * 2 * 2 * 2 .... = n 
2kpower = n 
k = logn (2)

for(i=1; i<n; i++)
{
  stmt; 
}
i = i+i+i+i+i ..... = n 
k = n 

- if we have a loop where value of i is going to  be multiplied than it is going to be : 
log n 
for(i=1; i<n; i=i*2)
{
  stmt; 
}
- if our output from log is decimal or float value, so we need to know if we want ot have C format value
- suppose n value = 8, 
n = 8 then 
i = 1, 2, 4, 8X = loop stops 
- we have 3 times loop run 
log 8 = 3
log 2 to power of 3 = 3log2
- since we have log in base 2 we can get rid of 2 and we are left with 3 

n = 10 then
i = 1, 2, 4, 8, 16X = loop stops here
- if we have log10, 10 is not exact number for power of 2, so we wont get exact number 
- we will recieve decimal value 
log 10 = 3.2 (this should be taken as seal value)
- which will correspont with our runtime which is 4 

- i value being fraction 
- dividing everytime starting from n 
for(i=n; i>=1; i=i/2)
{
  stmt;
}
- i value is starting with n, than n/2, next n2squared, than n2powerof3 .... 

i     n     n             n            n  
-- , --- , ---         , ---        , ---
n     2     2to2power     3to2power    n to k power

Assume i < 1 
 n 
--- < 1
 2 to power k 

 n 
--- = 1
 2 to power k 

n = 2 to power k 
k = logn 
O(log n)

------------------------
for(i=0; i*i<n; i++)
{
  stmt;
}
i*i<n
i*i>-n 
i to power of 2 = n 
i = square root of n 

------------------------
for(i=0; i<n; i++)
{
  stmt; --------- n 
}

- independent loops from one another

for(j=0; j<n; j++)
{
  stmt; ---------- n 
}
2n two independent loops together
O(n)

------------------------
- another example of two independent loops 
for(i=1; i<n; i*2)
{
  P++; ----------- log P 
}

for(j=1; j<P; j*2)
{
  stmt; ----------- log P 
}
- P = log n 
- and P is evaluted in upper loop 
O(log log n)

------------------------
for(i=0; i<n; i++) -------- n 
{
  for(j=0; j<n; j*2) ------ n * logn 
  {
  stmt; ------------------- n * logn 
  }
}
2nlogn+n
O(nlogn)

------------------------
for(i=0; i<n; i++) -------- O(n)
for(i=0; i<n; i=i+2) ------ n/2 O(n)
for(i=n; i>=1; i--) ------- O(n)
for(i=1; i<n; i*2) -------- O(log2n)
for(i=1; i<n; i*3) -------- O(log3n)
for(i=n; i>=1; i=i/2) ----- O(log2n)

// --------------------------------------------------------------------------------------------------------
1.5.3 Time Complexity of While and IF 

- Pascal language Syntax
for i = 1 to n do step 2    (1, 3, 5, 7, ...)
{
    stmt;
}
while(condition)         do                      repeat
{                        {                       {
    stmt;                   stmt;                   stmt; 
}                        } while (condition)     } until(condition);

- do while will execute as long as the condition is true 
- repeat until will execute until the condition is false 

// --------
- piece of code using while loop 
i = 0;    -------- 1 
while(i<n) ------- n+1
{
    stmt; -------- n 
    i++;  -------- n 
}
f(n) = 3n+2 
O(n)

- same code in C language
for(i=0; i<n; i++) ----- 1 + n+1 + n
{
    stmt; -------------- n
}
f(n)=3n+2
f(n)=2n+1
O(n)

---------------------
a = 1; 
while(a < b)
{
    stmt; 
    a = a * 2; 
}

a/1 
1 * 2 = 2
2 * 2 = 2to2power
2to2power * 2 = 2to3power
= 2 to k power 
- we dont know how many times is this going to happen

Terminate
a >= b 
a = 2tokpower
2tokpower >= b 
2tokpower = b 
k = log b 
O(log n)

- same code using for loop is: 
for(a=1; a<b; a=a*2)
{
    stmt; 
}

---------------
i = n;
while(i>1)
{
    stmt;
    i=i/2;
}
- is same as: 
for(i=n;i>1;i=i/2)
{
    stmt; 
}
----------------
i = 1;
k = 1; 
while(k<n)
{
  stmt; 
  k=k+1;
  i++;
}

i    k 
1    1
2    1+1=2
3    2+2
4    2+2+3
5    2+2+3+4
     m(m+1)
 m   ------
        2

k >= n
m(m+1) 
------ >= n 
   2
m to power 2 >= n 
m = square root of n 

O(square root of n)

- same loop written in for loop format: 
for(k=1; k<n; i++)
{
  stmt;
  k=k+1;
}

------------------
while(m!=n)
{
  if(m>n)
    m=m-n;
  else
    n=n-m; 
}

m = 6        m = 16
n = 3        n = 2 

m    n       m    n 
6    3       14   2       16/2
3    3       12   2       n/2 
0    3       10   2       O(n)
             8    2       min O(1)
             6    2
             4    2
             2    2

// --------------------------------------------------------------------------------------------------------
1.7 Types of functions 
O(1) = constant 

f(n) = 2  
f(n) = 5 
f(n) = 5000
f(n) = 1250 
f(n) = 1000000 
--------------
O(1)
- not dependent on the size of input, it is written as constant 

----------------------
O(log n) = Logarithmic 

f(n) = 2n+3
f(n) = 500n+700
f(n) = 2/5000 + 6 
- all of these are polynomials, and we write n
----------------------
O(n) = Linear 

----------------------
O(n2squared) = Quadratic 

----------------------
O(n3power) = Cubic

----------------------
O(2npower) = Exponential


------------------------------|
O(1) = constant               |
O(log n) = Logarithmic        |
O(n) = Linear                 |
O(n2squared) = Quadratic      |
O(n3power) = Cubic            |
O(2npower) = Exponential      |
------------------------------|

// --------------------------------------------------------------------------------------------------------
1.7.1 Compare Class of Functions 
1 < log n < square root of n < n < n log n < n2power < n3power < ntonpower

example: 

        log n       n       n2power         ntonpower 
          0         1          1                2
          1         2          4                4
          2         4         16               16
          3         8         64               256
          3.1....   9         81               512

n to power of 100 < 2 power of n 
- because n can be any number from 0 to infinity

COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1 COMMIT 1

// --------------------------------------------------------------------------------------------------------
1.8.1 Asymptotic Notations, Big Oh 
- mathematical background
- class of a function, we already know comparisons of functions 
- we need simple method for representing time complexity: 
Big-oh notation = UPPERBOUND of function 
big-omega       = LOWER BOUND of a function 
theta           = AVERAGE BOUND of a function 
- every function we represent is either: upperbound, lowerbound or averagebound 
- when we find time complexity of any function it will be one of these: 
1 < log n < square root of n < n < n log n < n2power < n3power < ntonpower
- if it is not one of these, than it will be multiple of them, otherwise we would not be able to graph them 

Example Big-Oh notation: 
The function f(n) = O(g(n)) if and only exist positive constants c and no
    such that f(n) <= c * g(n) for all n >= no
    
    sub-example: 
    f(n) = 2n+3                                    [10 = c, n = g(n)]
    2n+3 <= 10n n >= 1                      2n+3 <= 10n, n >= 1
    f(n) = O(n)                             [f(n)]       [for all n >= no]      
- g of n is n, there fore we can say f(n) = O(n)

    sub-example: 
    f(n) = 2n+3
    2n+3 <= 2n + 3n 
    2n+3 <= 5n   n >=1
    f(n) = O(n)
- if we put 1 there, it will be true
- if we put any other value in n, it will be greater

    sub-example: 
    f(n) = 2n+3
    2n+3 <= 2n2squared + 3n2squared
    2n+3 <= 5n2squared   n >=1
    f(n) = O(n2squared)
- the same function can also be O(n2squared)

- this f(n) = 2n + 3 belongs to this class, that means all functions
after n (n log n < n2power < n3power < ntonpower) BECOME UPPER BOUND 
- all the functions (1 < log n < square root of n) BECOME LOWER BOUND 
- n becomes AVERAGE BOUND 
                               |
1 < log n < square root of n < n < n log n < n2power < n3power < ntonpower

OMEGA NOTATION:
The function f(n) = OMEGA (g(n)) if and only exist positive constants c and no
  such that f(n) >= c * g(n) for all n >= no

  sub-example: 
  f(n) = 2n+3 
  2n+3>= 1*n     n>=1
  f(n)   c g(n)
  f(n) = OMEGA(n)

  sub-example: 
  f(n) = 2n+3 
  2n+3>= 1*log n     n>=1
  f(n)   c  g(n)
  f(n) = OMEGA(log n)

- useful one for OMEGA case is one which is closest = OMEGA(n)

THETA NOTATION: 
The function f(n) = OMEGA (g(n)) if and only exist positive constants c1, c2 and no
  such that c1 * g(n) <= f(n) <= c2*g(n) for all n >= no
  
  sub-example: 
  f(n) = 2n + 3 
  1 * n <= 2n+3 <= 5 * n 
  c1, g(n)  f(n)   c2, g(n)
  f(n) = THETA(n) 
- we cannot write inside THETA, any other thing except n, O(n)


1.8.2. Asymptotic Notations - Big Oh - Theta - Omega - PART 2

f(n) = 2n2power + 3n + 4
2n2power + 3n + 4 <= 2n2power + 5n2power + 4n2power
2n2power + 3n + 4 <= 9n2power     n>=1
f(n) = O(n2power)


f(n) = n2npower + 3n + 4 
2n2power + 3n + 4 >= 1 * n2power               OMEGA(n2power)
1 * n2power <= 2n2power + 3n + 4 <= 9n2power       O(n2power)


f(n) = n2power log n + n 
1 * n2power log n <= n2power log n <= 10 n2power log n 
O(n2power log n), OMEGA (n2power log n)
THETA (n2power log n)


f(n) = n! = n * (n-1) * (n-2) * ... * 3 * 2 * 1 
1 * 1 * * 1 * ... * 1 <= 1 * 2 * 3 ... * n < = n * n * n * n 
1 <= n! <= ntopowern
OMEGA(1), O(ntonpower)


f(n) = log n! 
log(1 * 1 * .... 1) <= log(1 * 2 * 3 ... * n) <= log(n * n * ... * n)
1 <= log n! <= log n2power 
OMEGA(1), O*|(n log n)

// --------------------------------------------------------------------------------------------------------
1.9 Properties of Asymptotic notations

General Properties
if f(n) is O(g(n)) then a * f(n) is O(g(n))
    sub example: 
    f(n) = 2n2power + 5 is O(n2power)
    then 7*f(n) = 7(2n2power + 5)
      = 14n2power + 35 is O(n2power)

Reflexive
if f(n) is given then f(n) = O(f(n))
    sub example: 
    f(n) = n2power   
    O(n2power)

Transitive 
if f(n) is O(g(n)) and g(n) is O(h(n))
then f(n) = O(h(n))
    sub example: 
    f(n) = n, g(n) = nto2power, h(n) = nto3power
    n is O(nto2power) and nto2power is O(n3power)
    then n is O(n3power)

Symmetric 
if f(n) is THETA(g(n)) then g(n) is THETA(f(n))
    sub example: 
    f(n) = n2power, g(n) = n2power
    f(n) = THETA(n2power)
    g(n) = THETA(n2power)

Transpose Symmetric
if f(n) = O(g(n)) then g(n) is OMEGA(f(n))
    sub example; 
    f(n) = n, g(n) = n2power
    then 
    n is O(n2power) 
    and 
    n2power is OMEGA(n)



if f(n) = O(g(n))
and f(n) = OMEGA(g(n))
g(n) <= f(n) <= g(n)
    f(n) = THETA(g(n))


if f(n) = O(g(n))
and d(n) = O(e(n))
then f(n) + d(n) = 
    sub example: 
    f(n) = n = O(n)
    d(n) = nto2power = O(nto2power)
    f(n) + d(n) = n + n2power = O(nto2power)

then f(n) + d(n) = O(max(g(n)))
    sub example: 
    f(n) = nto2power = O(n)
    d(n) = nto2power = O(nto2power)
    f(n) + d(n) = n2power + n = O(nto2power)

if f(n) = O(g(n))
and d(n) = O(e(n))
then f(n) * d(n) = O(g(n)*e(n))
       n      n2power

// --------------------------------------------------------------------------------------------------------
1.10.1 Comparison of functions 
n     nto2power          nto3power
2     2to2pwoer = 4      2to3power = 8 
3     3to2power = 9      3to3power = 27
4     4to2power = 16     4to3power = 64

nto2power         nto3power 
   Apply Log on Both sides 
log nto2power     log nto3power
log nto2power  <  log nto3power

-------------------------------------|
log ab = log a + log b               |
log a/b = log a - log b              |
log atopowerb = b log a              |
a topower(log b) = b topower(log a)  |
a topower b = n then b = log n       |
                            |        |
                            a        |
-------------------------------------|

f(n) = ntopower2 log n > g(n) = n(log n) to power of 10 
                      APPLY LOG 
log[n topower2 log n]           log[n(log n)to power of 10]
log n topower 2 + loglog n      log n + log (log n)
2logn + loglogn                 logn+ 10loglogn 

f(n) = 3n(n to power of (square root of n))            g(n) = 2 to power of (square root of n log n)
3 n to power (of square root of n)                     2 to power of (log n to power of (square root of n))
3 n to power (of square root of n)                     n to square root of n     
3 n to power (of square root of n)
2 n to power of 2

---------------------------------
1.10.2 Comparison of Functions #2 
f(n) = n to power of log n < g(n) = n to square root of n 
                      APPLY LOG 
log n to power of log n        log 2 to square root of n 
log n * log n                  square root of n log to power of 2 
log (to power of 2) n          square root of n = n to power of 1/2 
2 loglog n                     1/2 log n 


f(n) = 2 to power of log n     g(n) = n to power of square root of n 
log n * log to power of 2      square root of n, log n 
log n                          square root of n, log n 


f(n) = 2 to power of n         g(n) = 2 to power of 2n 
log 2 to power of n            log 2 to power of 2n 
n log 2                        2n log 2 

g 1 (n) = {n to power 3        n < 100  }
          {n to power 2        n >= 100 }
g 2 (n) = {n to power 2        n < 10000  }
          {n to power 3        n >= 10000 }

Exercise True / False 
1. (n+k) to power m = THETA(n to power m)          (n+3) to power of 2 = THETA(n to power 2)
2. 2 to power of n+1 = O(2 to power n)              2*2 to power of n 
3. 2 to power of 2n = O(2 to power of n)            4 to pwoer of n > 2 to power of n              
4. Square root(log n) = O(loglog n)
5. n to power of log n = O(2 to power of n)         log n * log n n 

// --------------------------------------------------------------------------------------------------------
1.11 Best, Worst and Average Case analysis 
1. Linear Search
2. Binary Search Tree 

1. Linear Search 

A 8 6 12 5 9 7 4 3 16 18
  0 1 2  3 4 5 6 7 8  9 
  key = 7 

Best case ---- searching key element present at first inolese
Best case Time ---- 1 O(1)
                B(n) = O(1)

Worst case ---- searching key at last index 
Worst case Time = n 
w(n) = n 
O(n)

Average case ---- all possible case time / no of cases
           1 + 2 + 3 + ... + n    n(n+1) / 2    n + 1 
Avg time = -------------------- = ---------- = -------
                     n                 n           2 

---------------|
B(n) = O(1)    |
w(n) = O(n)    |
A(n) = n+1 / 2 |
---------------|

B(n) = 1          w(n) = n 
B(n) = O(1)       w(n) = O(n)
B(n) = OMEGA(1)   w(n) = OMEGA(n)
B(n) = THETA(1)   w(n) = THETA(n)

2. Binary Search Tree 

           20 
         /    \
        10     30 
       /  \   /  \ 
       5  15 25  40 
Best case ---- search root ele 
Best case Time ---- B(n) = 1 
worst case ---- search for leaf ele
worst case Time ---- w(n) = log n 

40 -- 30 -- 25 -- 20 -- 15 -- 10 -- 5
-------------------------------------
                   n 
worst case Time - w(n) = h 
min w(n) = log n 
max w(n) = n 

// --------------------------------------------------------------------------------------------------------
1.12 Disjoint Sets Data Structure - Weighted Union and Collapsing Find 

Disjoint Sets 

1. Find 
2. Union 

S1 = {1, 2, 3, 4}
S2 = (5, 6, 7, 8)  

 u  v 
(4, 8)
(1, 5)

S1US2 = {1, 2, 3, 4, 5, 6, 7, 8}

  2 --- 3 
 /       \
1         4 
          
5         8
 \       / 
  6 --- 7


u = {1, 2, 3, 4, 5, 6, 7, 8}
S1 = {1, 2}
S2 = {3, 4}
S3 = {5, 6}
S4 = {7, 8}
S5 = {1, 2, 3, 4}                (2, 5)
S6 = {1, 2, 3, 4, 5, 6}          (1, 3)
S7 = {1, 2, 3, 4, 5, 6, 7, 8}    (6, 8)
                                 (5, 7)
1 ---- 3 
|      |
|      | 
2 ---- 4 
|
|
5 ---- 7
|      |
|      |
6 ---- 8  

u = {1, 2, 3, 4, 5, 6, 7, 8}
     1. 2. 3. 4. 5. 6. 7. 8. 

S1 = {1, 2} | S2 = {3, 4} | S3 = {5, 6} | S4 = {7, 8} | 
1. <-- 2.   | 3. <-- 4.   | 5. <-- 6.   | 7. <-- 8.

S6 = {1, 2, 3, 4, 5, 6}

    1 
   /|\
  2 | 5
    3  \ 
    |   6
    4

Parent = -1 -1 -1 -1 -1 -1 -1 -1 
          1  2  3  4  5  6  7  8

// --------------------------------------------------------------------------------------------------------
2. Divide and Conquer 

      P 
/   /  \  ... \ 
P1 P2  P3 ... Pk
|  |   |  ... |
S1 S2  S3 ... Sk
\  \   /  ... /
 \  \ /      /
      S

DAC(P)
{
    if(small(P))
    {
        S(P)
    }
    else 
    {
        divide P into P1, P2, p3, ... Pk 
        Apply DAC(P1), DAC(P2), ... 
        Combine(DAC(A)), DAC(P2),...
    }
}

// --------------------------------------------------------------------------------------------------------
2.1.1 Recurrence Relation (T(n)=T(n-1) + 1)

void Test(int n)
{
    if(n>0)
    {
        print("/d",n);
        Test(n-1);
    }
}
------
Test(3)

     Test(3)
     /      \
    -3      Test(2)
            /      \ 
          -2       Test(1)
                   /     \
                  -1     Test(0)
                            | 
                            x 
                        ---------
                        3 + 1 
                        f(n) = n + 1 call O(n)

- Recurrence method 

void Test(int n) ----- T(n)
{
    if(n>0)
    {
        print("/d",n); - 1
        Test(n-1); ----- T(n-1)
    }
}
T(n) = T(n-1) + 1 

T(n) = { 1          n = 0}
       { T(n-1)+1   n > 0}


- Substitution method 

void Test(int n) ----- T(n)
{
    if(n>0)
    {
        print("/d",n); - 1
        Test(n-1); ----- T(n-1)
    }
}

T(n) = { 1          n = 0}
       { T(n-1)+1   n > 0}

          |--------------------------------------\
          |                                      |
T(n) = T(n-1) + 1           T(n) = T(n-1) + 1    |  
                            T(n-1) = T(n-2) + 1--|
substitute T(n-1)           T(n-2) = T(n-3) + 1
T(n) = [T(n-2) + 1] + 1            |
T(n) = T(n-2) + 2 <----------------|
T(n) = [T(n-3) + 1] + 2
T(n) = T(n-3) + 3 
.... continues for k times 
T(n) = T(n-k) + k

T(n) = T(n-k) + k
Assume n - k = 0
... n = k 
T(n) = T(n-n) + n 
T(n) = T(0) + n 
T(n) = 1 + n 
O(n)

// --------------------------------------------------------------------------------------------------------
// 2.1.2 Recurrence Relation (T(n)=T(n-1) + n) #2

void Test(int n)         ----------- T(n)
{                        
    if(n>0)              ----------- 1 
    {
      for(i=0; i<n; i++) ----------- n + 1
      {
        print("/d",n);   ----------- n 
      } 
        Test(n-1);       ----------- T(n-1)
    }
}
-----------
T(n) = T(n-1) + 2n + 2

T(n) = T(n-1) + 2
T(n) = { 1             n = 0}
       {T(n-1) + n     n > 0}

       T(n)                                 ------------- n 
     /      \
    n       T(n-1)                          ------------- n - 1
            /      \  
          n-1      T(n-2)
                   /     \
                 n-2     T(n-3)             ------------- n - 2 
                            | 
                            T(2)            ------------- n - 3
                            /   \
                           2     T(1)       ------------- 2 
                                 /   \
                                1     T(0)  ------------- 1 
                                        |
                                        x 

0 + 1 + 2 ... + n - 1 + n = n(n+1) / 2 
                     T(n) = n(n+1) / 2 
                          = O(n to power of 2)

T(n) = T(n-1) + n --- [1.]    T(n) = T(n-1) + n 
        |                     T(n-1) = T(n-2) + n-1 
        |                                   |
        |-----------------------------------|
T(n) = [T(n-2) + n - 1] + n 
T(n) = T(n-2) + (n-1) + n             --- [2.]

T(n) = [T(n+3) + n - 2] + (n-1) + n 
T(n) = T(n-3) + (n+2) + (n-1) + n     --- [3.]

                  [4]
                   |
T(n) = T(n-k) + (n-(k-1)) + n-(k-2) ... + (n-1) + n 
Assume n - k = 0 
   ... n = k 
T(n) = T(n-n) + (n-n+1) + (n-n+2) + ... + (n-1) + n
T(n) = T(0) + 1 + 2 + 3 ... + (n-1) + n
T(n) = 1 + n(n+1) / 2 
O(n to power of 2)

// --------------------------------------------------------------------------------------------------------
2.1.3 Recurrence Relation (T(n)=T(n-1) + log n)

void Test(int n)         ----------- T(n)
{                        
    if(n>0)              
    {
      for(i=0; i<n; i*2) 
      {
        print("/d",i);   ----------- log n 
      } 
        Test(n-1);       ----------- T(n-1)
    }
}
---------
T(n) = T(n-1) + log n 
T(n) = { 1                n = 0}
       {T(n-1) + log n    n > 0}

       T(n)                                  
     /      \
   log n    T(n-1)                           
            /      \  
        log(n-1)    T(n-2)
                   /     \
                log(n-2)  T(n-3)               
                            | 
                            T(2)             
                            /   \
                        log 2     T(1)        
                                 /   \
                              log 1     T(0)  
                                        |
                                        x 
log(n-1) + ... + log 2 + log 1 
log[n * (n-1) * ... * 2 * 1]
log n ! 
O(n log n)

T(n) = { 1                 n = 0}
       {T(n-1) + log n     n > 0}
T(n) = T(n-1) + log n                         ------ [1.] 
T(n) = [T(n-2) + log (n-1)] + log n
T(n) = T(n-2) + log (n-1) + log n             ------ [2.]
T(n) = [T(n-3) + log(n-2)] + log(n-1) + log n 
T(n) = T(n-3) + log(n-2) + log(n-1) + log n   ------ [3.]

T(n) = T(n-k) + log 1 + log 2 + ... + log(n-1) + log n 
n - k = 0
n = k 
T(n) = T(0) + log n! 
T(n) = 1 + log n! 
O(n log n)

T(n) = T(n-1) + 1 ----- O(n)
T(n) = T(n-1) + n ----- O(n to power of 2)
T(n) = T(n-1) + log n ----- O(n log n)
T(n) = T(n-1) + n to power of 2 ----- O(n to power of 3)
T(n) = T(n-2) + 1 ----- n/2 O(n)
T(n) = T(n-100) + n ----- O(n to power of 2)
T(n) = 2T(n-1) + 1  

// --------------------------------------------------------------------------------------------------------
Recurrence Relation T(n) = 2 T(n-1) + 1 

Algorithm Test(int n) ----- T(n)
{
  if(n>0)
  {
    printf("/d",n)     ----- 1 
    Test(n-1);         ----- T(n-1)
    Test(n-1);         ----- T(n-1)
  }
}
------
T(n) = 2T(n-1) + 1 

T(n) = {1                n = 0 }
       {2T(n-1) + 1      n > 0 }

          T(n)                                         ----- 1 = 1 
      /    |    \
      1  T(n-1)  T(n-1 )---------/--|----\             ----- 2 = 2 to power of 1
        /  |   \                /   |     \
       1 T(n-2) T(n-2)          1  T(n-2)  T(n-2)      ----- 4 = 2 to power of 2
       ...  ...  ...            ... ...   ...
       ...  ...  ...            ... ...   ...          ----- 8 = 2 to power of 3
                                                        ...
                                                        ... 
                                                        ----- 2 to power of k

1 + 2 + 2 to power of 2 + 2 to power of 3 + ... + 2 to power of k = 2 (to power of k + 1) 
a + ar + ar (to power of 2) + ar (to power of 3) + ... + ar (to power of k) = 
    (r (to power of k+1) - 1)
= a -------------------------
            r - 1
a = 1 
r = 2 
    1 (2 (to power of k+1) -1)
= ---------------------------- 
              2 - 1 

= 2 (to power of k+1) -1

Assume n - k = 0 
       n = k 
= 2 (to power of n+1) - 1
O(2 to power of n)

T(n) = 2T(n-1) + 1                        ------ [1.] 
T(n) = 2[T(n-2) + 1] + 1
T(n) = 2 (to power of 2) * T(n-2) + 2 + 1      ------ [2.]
     = 2 (to power of 2) * [2T(n-3) + 1 ] + 2 + 1
T(n) = 2 (to power of 3) * T(n-3) + 2 (to power of 2) + 2 + 1   ------ [3.]

T(n) = 2 (to power of k) T(n-k) + 2(to power of k -1) + 2(to power of k -2) + 1
Assume n - k = 0 
n = k 
= 2(to power of n) T(0) + 1 + 2 + 2 to power of 2 + ... + 2(to power of k -1)
= 2(to power of n) * 1 + 2(to power of k) - 1
= 2(to power of n) + 2(to power of n) - 1 
T(n) = 2(to power of n+1) - 1 
O(2 to power of n)
THETA(2 to power of n)

// --------------------------------------------------------------------------------------------------------
2.2 Masters Theoren: Recurrence Relation 

T(n) = T(n-1) + 1 ----- O(n)
T(n) = T(n-1) + n ----- O(n to power of 2)
T(n) = T(n-1) + log n ----- O(n log n)
T(n) = 2T(n-1) + 1 ----- O(2 to power of n)
T(n) = 3T(n-1) + 1 ----- O(3 to power of n)
T(n) = 2T(n-1) + n ----- O(n 2 to power of n)

T(n) = aT(n-b) + f(n)
a>0   b>0   and f(n) = O(n to pwoer of k) where K >= 0 

case 
1    if a < 1    O(n to power of k)
                 O(f(n))
2    if a = 1    O(n to power k+1)
                 O(n*f(n))
3    if a > 1    O(n to power of k, a to power of n/b)
                 O(f(n)a to power n/b)

// --------------------------------------------------------------------------------------------------------
2.3.1 Recurrence Relation Dividing Function 

Algorithm Test(int n)     -----T(n)
{
  if(n>1)                 
  {
    printf("/d",n);       ----- 1 
    Test(n/2);            ----- T(n/2)
  } 
}
-------------
T(n) = T(n/2) + 1 

T(n) = { 1                n = 1 }
       { T(n/2)           n > 1 }

       T(n)                                    ----- 1    
     /      \
    1        T(n/2)                            ----- 1      
            /      \  
           1    T(n/2 to power of 2)           ----- 1
                   /     \
                  1     T(n/2 to power of 3)   ----- 1           
                            ...
                            ...
                            T(n/2 to power of k)
                            n/2 to power of k = 1 
K steps 
n / 2 to power of k = 1 
n = 2 to power of k 
k = log n 

2 to power of 5 = 32 
5 = log 32 
a to pwoer of b = c 
b = log c 
O(log n)

T(n) = T(n/2) + 1                         ------ [1.] 

T(n) = [T(n/2 to power of 2) + 1] + 1
T(n) = T(n/2 to power of 2) + 2           ------ [2.]
T(n) = T(n/2 to power of 3) + 3           ------ [3.]
T(n) = T(n/2 to power of k) + k           ------ [4.]

T(n) = T(n/2 to power of k) + k 
Assume n / 2 to power of k = 1
n = 2 to power of k and k = log n  
T(n) = T(1) + log n 
T(n) = 1 + log n  
O(log n)

// --------------------------------------------------------------------------------------------------------
Recurrence Relation T(n) = 2 T(n-1) + 1 

Algorithm Test(int n) ----- T(n)
{
  if(n>0)
  {
    printf("/d",n)     ----- 1 
    Test(n-1);         ----- T(n-1)
    Test(n-1);         ----- T(n-1)
  }
}
------
T(n) = 2T(n-1) + 1 

T(n) = {1                n = 0 }
       {2T(n-1) + 1      n > 0 }

          T(n)                                         ----- 1 = 1 
      /    |    \
      1  T(n-1)  T(n-1 )---------/--|----\             ----- 2 = 2 to power of 1
        /  |   \                /   |     \
       1 T(n-2) T(n-2)          1  T(n-2)  T(n-2)      ----- 4 = 2 to power of 2
       ...  ...  ...            ... ...   ...
       ...  ...  ...            ... ...   ...          ----- 8 = 2 to power of 3
                                                        ...
                                                        ... 
                                                        ----- 2 to power of k

1 + 2 + 2 to power of 2 + 2 to power of 3 + ... + 2 to power of k = 2 (to power of k + 1) 
a + ar + ar (to power of 2) + ar (to power of 3) + ... + ar (to power of k) = 
    (r (to power of k+1) - 1)
= a -------------------------
            r - 1
a = 1 
r = 2 
    1 (2 (to power of k+1) -1)
= ---------------------------- 
              2 - 1 

= 2 (to power of k+1) -1

Assume n - k = 0 
       n = k 
= 2 (to power of n+1) - 1
O(2 to power of n)

T(n) = 2T(n-1) + 1                        ------ [1.] 
T(n) = 2[T(n-2) + 1] + 1
T(n) = 2 (to power of 2) * T(n-2) + 2 + 1      ------ [2.]
     = 2 (to power of 2) * [2T(n-3) + 1 ] + 2 + 1
T(n) = 2 (to power of 3) * T(n-3) + 2 (to power of 2) + 2 + 1   ------ [3.]

T(n) = 2 (to power of k) T(n-k) + 2(to power of k -1) + 2(to power of k -2) + 1
Assume n - k = 0 
n = k 
= 2(to power of n) T(0) + 1 + 2 + 2 to power of 2 + ... + 2(to power of k -1)
= 2(to power of n) * 1 + 2(to power of k) - 1
= 2(to power of n) + 2(to power of n) - 1 
T(n) = 2(to power of n+1) - 1 
O(2 to power of n)
THETA(2 to power of n)

// --------------------------------------------------------------------------------------------------------
2.2 Masters Theoren: Recurrence Relation 

T(n) = T(n-1) + 1 ----- O(n)
T(n) = T(n-1) + n ----- O(n to power of 2)
T(n) = T(n-1) + log n ----- O(n log n)
T(n) = 2T(n-1) + 1 ----- O(2 to power of n)
T(n) = 3T(n-1) + 1 ----- O(3 to power of n)
T(n) = 2T(n-1) + n ----- O(n 2 to power of n)

T(n) = aT(n-b) + f(n)
a>0   b>0   and f(n) = O(n to pwoer of k) where K >= 0 

case 
1    if a < 1    O(n to power of k)
                 O(f(n))
2    if a = 1    O(n to power k+1)
                 O(n*f(n))
3    if a > 1    O(n to power of k, a to power of n/b)
                 O(f(n)a to power n/b)

// --------------------------------------------------------------------------------------------------------
2.3.1 Recurrence Relation Dividing Function 

Algorithm Test(int n)     -----T(n)
{
  if(n>1)                 
  {
    printf("/d",n);       ----- 1 
    Test(n/2);            ----- T(n/2)
  } 
}
-------------
T(n) = T(n/2) + 1 

T(n) = { 1                n = 1 }
       { T(n/2)           n > 1 }

       T(n)                                    ----- 1    
     /      \
    1        T(n/2)                            ----- 1      
            /      \  
           1    T(n/2 to power of 2)           ----- 1
                   /     \
                  1     T(n/2 to power of 3)   ----- 1           
                            ...
                            ...
                            T(n/2 to power of k)
                            n/2 to power of k = 1 
K steps 
n / 2 to power of k = 1 
n = 2 to power of k 
k = log n 

2 to power of 5 = 32 
5 = log 32 
a to pwoer of b = c 
b = log c 
O(log n)

T(n) = T(n/2) + 1                         ------ [1.] 

T(n) = [T(n/2 to power of 2) + 1] + 1
T(n) = T(n/2 to power of 2) + 2           ------ [2.]
T(n) = T(n/2 to power of 3) + 3           ------ [3.]
T(n) = T(n/2 to power of k) + k           ------ [4.]

T(n) = T(n/2 to power of k) + k 
Assume n / 2 to power of k = 1
n = 2 to power of k and k = log n  
T(n) = T(1) + log n 
T(n) = 1 + log n  
O(log n)

// --------------------------------------------------------------------------------------------------------
2.3.2 Recurrence relation - substitution

T(n) = { 1                n = 1 }
       { T(n/2) + n       n > 1 }

       T(n)                                           
     /      \
    n        T(n/2)                                       ----- n
            /      \  
          n/2       T(n/2 to power of 2)                  ----- n / 2 
                   /     \ 
   n/2(to power of 2)     T(n/2 to power of 3)            ----- n / 2 to power of 2 
                          | ... 
                          | ... 
                          T()
                         /   \
    T(n / 2 to power of k)    n / 2 to power of k - 1     ----- n / 2 to power of k

T(n) = n + n/2 + n/2 (to power of 2) + n/2(to power of 3) + ... + n/2 to pwoer of k 
T(n) = [ 1 + 1/2 + 1/2(to power of 2) + 1/2 (to power of 3) + ... + 1/2 to power of k]  

     __ k 
    /
= n \ 1 / 2 to power of i 
    /
    \__ i = 0 
= 1 

= n * 1 
T(n) = n 
O(n)

T(n) = T(n/2) + n                         ------ [1.] 

T(n) = [T(n/2 to power of 2) + n/2] + n
T(n) = T(n/2 to power of 2) + n/2 + n           ------ [2.]
T(n) = T(n/2 to power of 3) + n/2(to power of 2) + n/2 + 2           ------ [3.]
T(n) = T n/2(to power of k) + n / 2(to power of k-1) + n / 2(to power of k-2) + ... + n/2 + n 

T(n) = T(n/2(to power of 16) + n/2(to power of k-1) + ... + n/2 to power of 2 + )

Assume n / 2(to power of k) = 1 
.. n = 2(to power of k) and k = log n 
T(n) = T(1) + n[1/2(to power of k-1) + 1/2(to power of k-2) + ... + 1/2 + 1 ]
T(n) = 1 + n[1 + 1]
T(n) = 1 + 2n 
O(n)

// --------------------------------------------------------------------------------------------------------
2.3.3 Recurrence Relation 

void Test(int n)            ----- T(n)
{
  if(n>1)
  {
    for(i=0;i<n;i++)
    {
      stmt;                 ----- n 
    }
    Test(n/2);              ----- T(n/2)
    Test(n/2);              ----- T(n/2)
  }
}
---------
T(n) = 2T(n/2) + n

T(n) = {1               n = 1 } 
       {2T(n/2) + n     n > 1 }

        T(n)
     /   |   \
T(n/2) T(n/2) n 

                 n 
                / \
             n/2   n/2
          /  \        /         \
  n/2(to2)  n/2(to2)  n/2(to2)  n/2(to2)
  ...         ...        ...       ...
  | 
  n / 2(to power of k)
  nk 
  n log n 

  Assume n/2(to power of k) = 1 
  n = 2 to power of k 
  k = log n 

T(n) = 2T(n/2) + n --- [1.]    T(n) = 2T(n/2) + n 
        |                      T(n/2) = 2T(n/2 to pwoer of 2) + n / 2 
        |                                   |
        |-----------------------------------|
= 2[2T(n/2(to power of 2) + n/2)] + n 

T(n) = 2(to power of 2) * T(n/2(to power of 2)) + n + n      --- [2.] 
        |                                                  T(n/2) = 2T(n/2 to pwoer of 2) + n / 2 
        |                                                              |
        |--------------------------------------------------------------|
= 2(to power of 2)[2T(n/3(to power of 3)) + n/2(to power of 2)] + 2n 

T(n) = 2(to power of 3) T(n/2(to power of 3) + 3n)            --- [3.]
T(n) = 2(to power of k) T(n/2(to power of k)) + k n 
Assume
T(n/2(to power of k)) = T(1)
n/2 to power of k = 1         n = 2 (to power of k)
k = log n

T(n) = 2(to power of k) T(1) + k n 
T(n) = n * 1 + n log n 
O(n log n)

// --------------------------------------------------------------------------------------------------------
2.4.1 Master theorem for Dividing functions 

T(n) = aT(n/b) + f(n)
a >= 1     f(n) = THETA(n(topowerof k)log n)
b >= 1 

1: log a 
2: k 

case 1: if log a > k then THETA(n (to power of log a))
case 2: if log a = k 
               if P > -1 THETA(n(to power of k)log(to power of P+1)n)
               if P = -1 THETA(n(to power of k)loglog n)
               if P < -1 THETA(n(to power of k))
case 3: if log a < k 
               if P >= 0 THETA(n(to power k)log n)
               if P < 0  THETA(n(to power of k))

T(n) = 2T(n/2) + 1 
a = 2 
b = 2 
f(n) = THETA(1)
     = THETA(n log n)
k = 0, p = 0 

log 2 = 1 > k = 0 
case 1: THETA(n(to power of 1))

T(n) = 4T(n/2) + n 
log 4 = 2 > k = 1     p = 0 
THETA(n to power of 2)

T(n) = 8T(n/2) + n(to power of 2)
log 8 = 3 > k = 2     p = 0
THETA(n(to power of 3)) 

T(n) = 9T(n/3) + n(to power of 1)
log 9 = 2 > k = 1 
THETA(n(to power of 2))
T(n) = 9T(n/3) + n(to power of 2)
log 9 = 2 = k = 2 
O(n(to power of 2))

T(n) = 8T(n/2) + n log n
THETA(n to power of 3)

T(n) = 2T(n/2) + n(to power of 1)
log 2 = 1   k = 1   P = 0 
THETA(n log n)

T(n) = 4T(n/2) + n(to power of 2)
log 4 = 2    k = 2 
THETA(n(to power of 2) log n)

T(n) = 4T(n/2) + n(to power of 2)log n
log 4 = 2    k = 2 
THETA(n(to power of 2) log(to powr of 2) n)

T(n) = 4T(n/2) + n(to power of 2)log(to power of 2) n
log 4 = 2    k = 2 
THETA(n(to power of 2) log(to powr of 3) n)

T(n) = 4T(n/2) + n(to power of 2)log(to power of 5) n
log 4 = 2    k = 2 
THETA(n(to power of 2) log(to powr of 6) n)

T(n) = 8T(n/2) + n(to power of 3)
log 8 = 3    k = 3
THETA(n(to power of 3) log n)

T(n) = 2T(n/2) + n(to power of 1)/log n
log 2 = 1   k = 1   p = -1 
THETA(n log logn)

T(n) = 2T(n/2) + n(to power of 1)/log(to power of -2) n
log 2 = 1   k = 1   p = -2 
THETA(n)

T(n) = T(n/2) + n(to power of 2)
log(to power of 1) = 0 < k = 2 
THETA(n(to power of 2))

T(n) = 2T(n/2) + n(to power of 2)
log(to power of 2) = 1 < k = 2 
THETA(n(to power of 2))

T(n) = 2T(n/2) + n(to power of 2) log n 
log(to power of 2) = 1 < k = 2 
THETA(n(to power of 2)log(to power of 2) n)

T(n) = 4T(n/2) + n(to power of 3)
log(to power of 2) = 2 < k = 3
THETA(n(to power of 3))

T(n) = 4T(n/2) + n(to power of 3) / log n 
log(to power of 2) = 2 < k = 3
THETA(n(to power of 3))

// --------------------------------------------------------------------------------------------------------
2.4.2 Examples for Master Theorem

Case 1: 
T(n) = 2T(n/2) + 1                   ----- THETA(n(to power of 1))
T(n) = 4T(n/2) + 1                   ----- THETA(n(to power of 2))
T(n) = 4T(n/2) + n(to power of 1)    ----- THETA(n(to power of 2))
T(n) = 8T(n/2) + n(to power of 2)    ----- THETA(n(to power of 3))
T(n) = 16T(n/2) + n(to power of 2)   ----- THETA(n(to power of 4))

Case 3: 
T(n) = T(n/2) + n(to power of 1)                                  ----- THETA(n)
T(n) = 2T(n/2) + n(to power of 2)                                 ----- THETA(n(to power of 2))
T(n) = 2T(n/2) + n(to power of 2) log n                           ----- THETA(n(to power of 2)log n)
T(n) = 4T(n/2) + n(to power of 3) log(to power of 2) n            ----- THETA(n(to power of 3)log(to power of 2) n)
T(n) = 2T(n/2) + n(to power of 2) / log n                         ----- THETA(n(to power of 2))

Case 2:  
T(n) = T(n/2) + 1                            ----- THETA(log n)
T(n) = 2T(n/2) + n                           ----- THETA(n log n)
T(n) = 2T(n/2) + n log n                     ----- THETA(n log(to power of 2)n)
T(n) = 4T(n/2) + n(to power of 2)            ----- THETA(n(to power of 2))
T(n) = 2T(n/2) + n(to power of 1) / log n    ----- THETA(n log log n)
T(n) = 2T(n/2) + n / log n                   ----- THETA(n)             

// --------------------------------------------------------------------------------------------------------
2.5 Root function (Recurrence Relation)

void Test(int n)                 ----- T(n)
  {
    if(n>2)
    {
      stmt;                      ----- 1 
      Test(squareroot(n));       ----- T(square root of n)
    }
  }
---------
T(n) = T(square root of n) + 1 

T(n) = {1                                  n = 2 }
       {T(square root of(n)) + 1           n > 2 } 

T(n) = T(square root of(n)) + 1                     
T(n) = T(n(to power of 1/2)) + 1                    ----- 1
T(n) = T(n(to power of 1/2(to power of 2))) + 2     ----- 2
T(n) = T(n(to power of 1/2(to power of 3))) + 3     ----- 3
...
T(n) = T(n(to power of 1/2(to power of k))) + k     ----- 4 

Assume n = 2(to power of m)
T(2(to power of m)) = T(2(to power of m / 2 to power of k)) + k 
Assume T(2(to power of m / 2 to power of k)) = T(2(to power of 1))
... m / 2(to power of k) = 1 
m = 2(to power of k) and k = log m 
n = 2(to power of m), m = log n 
k = loglog n 
THETA(loglog n)

// --------------------------------------------------------------------------------------------------------
2.6.1 Binary search Iterative method 

A 3 6 8 12 14 17 25 29 31 36 42 47 53 55 62
  1 2 3 4  5  6  7  8  9  10 11 12 13 14 15 

3 < -- l 
62 < -- h 

key = 42 
________________________________
| l  |  h  |   mid = l + h / 2 |
|----|-----|-------------------|
| 1  |  15 |  1 + 15 / 2 = 8   |
|----|-----|-------------------|
| 9  |  15 | 9 + 15 / 2 = 12   |
|----|-----|-------------------|
| 9  |  11 | 9 + 11 / 2 = 10   |
|----|-----|-------------------|
| 11 |  11 | 11 + 11 / 2 = 11  |
|----|-----|-------------------|

key = 12 
________________________________
| l  |  h  |   mid = l + h / 2 |
|----|-----|-------------------|
| 1  |  15 |  1 + 15 / 2 = 8   |
|----|-----|-------------------|
| 1  |   7 | 1 + 7 / 2 = 4     |
|----|-----|-------------------|

key = 30 
________________________________
| l  |  h  |   mid = l + h / 2 |
|----|-----|-------------------|
| 1  |  15 |  1 + 15 / 2 = 8   |
|----|-----|-------------------|
| 9  |  15 | 9 + 15 / 2 = 12   |
|----|-----|-------------------|
| 9  |  11 | 9 + 11 / 2 = 10   |
|----|-----|-------------------|
| 9  |  9  | 9 + 9 / 2 = 9     |
|----|-----|-------------------|
| 9  |  8  | X X X X X X X X X |
|----|-----|-------------------|

int BinSearch(A, n, key)
{
  l = i; h = n; 
  while(l <= h)
  {
    mid=(l+h)/2;
    if(key==A[mid])
      return mid;
    if(key<A[mid])
        h = mid - 1;
    else 
        l = mid+1;
  }
  return 0;
}

                  8
                /   \
               4      12
             /  \    /   \
            2   6    10  14 
           / \ / \  / \  / \
           1 3 5 7  9 11 13 15
15 + 1 = 16, log 16 = 4 

min ----- 1 O(1)
max ----- log n O(log n)

// --------------------------------------------------------------------------------------------------------
2.6.1 Binary Search Recursive Method 

A 3 6 8 12 14 17 25 29 31 36 42 47 53 55 62
  1 2 3 4  5  6  7  8  9  10 11 12 13 14 15 

Algorithm RbinSearch(l,h,key)    ----- T(n)
{
  if(l==h)
  {
    if(A[l]==key)                            ----- 1 
        return l; 
    else
        return 0; 
  }
  else
  {
    mid = (l + h)/2;                          ----- 1 
    if(key = A[mid])                          ----- 1 
         return mid;  
    if(key < A[mid])                          ----- 1 
         return RbinSearch(l,mid -l, key);
    else                                      ----- T(n/2)
         return RbinSearch(mid + l, h, key);
  }
}

T(n) = {1             n = 1 }
       {T(n/2) + 1    n > 1 }
T(n) = T(n/2) + 1 
log(to power of 1) = 0 
O(log n)

// --------------------------------------------------------------------------------------------------------
2.6.3 Heap sort, Heapify, Heap, Priority Queues

1. Array Representation of BT 
2. Complete Binary Tree
3. Heap
4. Insert & Delete
5. Heap Sort   
6. Heapify 
7. Priority Queue 

     A                  A                  A 
    / \                / \                / \
   B   C               B  C              B   C 
  / \ / \             / \                   / \
  D E F  G            D E                   D  E

(T)A B C D E F G       A B C D E         A B C - - D E 
   1 2 3 4 5 6 7       1 2 3 4 5         1 2 3 4 5 6 7 

if a Node is at index ----- i 
its left child is at  ----- 2 * 1 
its right child is at ----- 2 * i + 1 
its parent is at      ----- i / 2 

Is this binary tree ? 

     A                  A                  A 
    / \                / \                / \
   B                  B   C              B   C 
  / \                /                      / 
  D E               D                      D 
  [yes]             [yes]               [no] 

     A                  A                  A 
    / \                / \                / \
   B   C              B   C              B   C 
  / \                / \   \            / \ / \
 D   E              D   E   F           D E F G    
/ \                                    /
F  G                                   H 
[yes]               [no]               [yes]

----
Heap

    Max Heap                    Min Heap 
       50                         10
     /    \                       / \ 
    30     20                    30  20 
  /  \    /   \                 / \  / \
 15   10  8   16               35 40 32 25 

H 50 30 20 15 10 8  16         H 10 30 20 35 40 32 25 
  1  2  3  4  5  6  7            1  2  3  4  5  6  7 

-----------
Insert Sort 
            50
          /    \
         30     20
        /  \    /   \
       15  10   8   16 
      / 
     [60] = insert  
H = 50 30 20 15 10 8  16 | 60 
    1  2  3  4  5  6  7  | 8 

            60 
          /    \
         50     30
        /  \    /   \
       30  10   8   16 
      / 
     [15] = insert  
H = 60 50 20 30 10 8  16 | 15 
    1  2  3  4  5  6  7  | 8 

------
Delete 
            60 
          /    \
         30 <-> 20
        /  \    /  
       15  10   8   
      / 
     [15] = insert  

H = 60 50 20 30 10 8  16 | 15 
    1  2  3  4  5  6  7  | 8 

            30 
          /    \
         16     20
        /  \    /  
      15<->10   8   
H = 30 10 20 15 10 8  - 
    1  2  3  4  5  6  7       
       
-------
HEAP 

create Heap - heap 
[1.] 

     10 

|10|20|15|30|40|
|1 |2 |3 |4 |5 |

[2.]
     20
    /
   10
_____________________
|20 |10 |   |   |   |
|1  |2  |   |   |   |
     *exchanged  

[3.]
     20  
    /  \ 
  10    15
_____________________
|20 |10 |15 |   |   |
|1  |2  |3  |   |   |
         *added   

[4.]
     30  
    /  \ 
  20    15
 /
10 
_____________________
|30 |20 |15 |10 |   |
|1  |2  |3  |4  |   |
- 30 gets exchanged with 20 
- 20 gets exchanged with 10 
            
[5.]
     40  
    /  \ 
  30    15
 /  \ 
10   20
_____________________
|40 |30 |15 |10 |20 |
|1  |2  |3  |4  |5  |
- 40 gets exchanged with 30
- 30 gets exchanged with 20
= 20 is moved to place 5 

2. STEP FOR HEAP SORT  
- we have already created a heap 
- deleting elements 

[1.]
     40  
    /  \ 
  30    15
 /  \ 
10   20

     30  
    /  \ 
  20    15
 /  X 
10   X 
_____________________
|40 |30 |15 |10 |20 |
|1  |2  |3  |4  |5  |
- 40 gets deleted 20 takes its place 
- 20 gets exchanged with 30
- 30 takes lead place 
_____________________
|30 |20 |15 |10 |   |
|1  |2  |3  |4  |   |

[2.]
     30  
    /  \ 
  20    15
 /  
10 

     20  
    /  \ 
  10    15

- 30 gets deleted 10 takes its place 
- 10 gets exchanged with 20 
- 20 takes lead place 
_____________________
|20 |10 |15 |   |   |
|1  |2  |3  |   |   |

[3.]
     20  
    /  \ 
  10    15

     15  
    /  
  10    

- 20 gets deleted 15 takes it place 
_____________________
|15 |10 |   |   |   |
|1  |2  |   |   |   |

[4.]
     15  
    /  
  10

- 15 gets deleted 10 takes its place 
_____________________
|15 |10 |   |   |   |
|1  |2  |   |   |   |

[5.] 
     10 
_____________________
|10 |   |   |   |   |
|2  |   |   |   |   |

------- 
Heapify 
            10
          /     \
         20      15
        /  \    /  \
       12  40  25  18 
 
H 10 20 15 12 40 25 18 
   1  2  3  4  5  6  7

- 25 gets exchanged with 15 
- 40 gets exchanged with 10
- 20 gets excchanged with 10  

create -> O(n log n)
Heapify -> O(n)

--------------
Priority Queue 

- small number 
Higher Priority 
A 8 6 3 10 5 4 9 
Min heap 
             3
          /     \
         5       9
        /  \    /  \
       10  8   6    9 

- large number 
Higher Priority
B 8 6 3 10 5 4 9 
            10
          /     \
         8       9
        /  \    /  \
       6    5  3    4 

// --------------------------------------------------------------------------------------------------------
2.7.1 Two way MergeSort - Iterative method 

Merge 

A    B    C 
2    5     
8    9 
15   12 
18   17 

A = i 
B = j 
C = k 

1. i = 2     = 1. k 
1. j = 5     = 2. k 
2. i = 8     = 3. k 
2. j = 9     = 4. k 
3. i = 15    = 5. k 
3. j - 12    = 6. k 
4. i = 18    = 7. k 
4. j = 17    = 8. k 

A    B    C 
2    5    2 
8    9    5 
15   12   8 
18   17   9  
m    m    15    THETA(m+n)
          12
          18
          17 = k 

Algorithm Merge(A,B,m,n)
{
  i = 1; j = 1; k = 1
  while(i<=m && j <=n)
  {
  if(A[i] < B[j])
     C[k++] = A[i++]; 
  else 
     C[k++] = B[j++];
  }
for( ; i<m; i++)
     C[k++ = A[i]]; 
for( ;j<=n;j++)
     C[k++] = B[j]; 

---------
Merge 
4-Way merging 
M-way Merging 

A   B   C   D 
4   3   8   2 
6   5   10  4 
12  9   16  18 

- first is taken 4, 3, 8, 2 = 2 < 3 < 4
- 2 is moved to number under which is 4, 3 to 5 and 4 to 6 
- 8 is left intact since it is still largest of number that are acutal = 6, 5, 8, 4

L 
2 
3 
4 
4 
5 ..... 

A   B   C   D 
4   3   8   2 
6   5   10  4 
12  9   16  18 
 \  /    \  / 
  3       2
  4       4
  5       8 
  6       10 
  9       16 
  12      18 
   \      /
    \    /
     ...
     ... 

A B C D 
A + B = l1 
l1 + C = l2 
l2 + D = l3 

A B C D 
C + D = l1 
l1 + B = l2 
l2 + A = l3 

-------------------
2-way Merge Sort                     | 
                                     | 8 elements / 2 / 2 / 2 = 1 
9  3  7  5  6  4  8  2               | 
\  /  \  /  \  /  \  /               | 
3  9  5  7 | 4  6  2  8    I. pass   | n   8 / 2(to power of 3) = 1
   \  /        \  /                  | 
3  5  7  9 | 2  4  6  8    II. pass  | n   8 = 2(to power of 3)  
         \   /                       | 
     2 3 4 5 6 7 8 9      III. pass  | n   8 = 2(to power of 3)
                                     |     log 8 = 3 
                                     |     (base 2)
                                     |     == number of passes log n 

// --------------------------------------------------------------------------------------------------------
2.7.2 Merge Sort Algorithm 

9  3  7  5  6  4  8  2   | Algorithm MergeSort(l, h)              
\  /  \  /  \  /  \  /   | {
3  9  5  7 | 4  6  2  8  |     if(l<h) 
   \  /        \  /      |     {
3  5  7  9 | 2  4  6  8  |         mid = (l+h)/2;
         \   /           |         MergeSort(6,mid);
     2 3 4 5 6 7 8 9     |         MergeSort(mid+1,h);
                         |         Merge(l,mid,h);
                         |      }
                         | }

Time taken
____  ____   ____  ____   ----- n 
3  9  5  7 | 4  6  2  8  
   \  /        \  /    
___________ ___________   ----- n 
3  5  7  9 | 2  4  6  8  
         \   /   
     _______________      ----- n         
     2 3 4 5 6 7 8 9      n * log n 

Talking Numbers 
9  3  7  5  6  4  8  2
     /          \
  3 5 7 9     2 4 6 8 
    / \         / \
  3 9  5 7    4 6  2 8 
 /  \  /  \   / \  / \ 
 9  3  7  5   6  4 8  2 

 Algorithm MergeSort(l, h)      ----- T(n)        
    {
        if(l<h) 
       {
        mid = (l+h)/2;          ----- 1 
        MergeSort(6,mid);       ----- T(n/2)
        MergeSort(mid+1,h);     ----- T(n/2)
        Merge(l,mid,h);         ----- n 
       }  
    }
T(n) = 2T(n/2) + n 

T(n) = { 1               n = 1 }
       { 2T(n/2) + n     n > 1 }
a = 2 
b = 2        log 2 = 1 
f(n) = n     n(to power of k) = n(to power of 1)

log 2 = k 
THETA(n log n)

// --------------------------------------------------------------------------------------------------------
2.7.3 Merge Sort in Depth 

Pros 
1. Large size List 
2. Linked List 
3. External Sorting (RAM)
4. Stable 

Cons 
1. Extra Space (not inplace sort)
2. No small problem
3. Recursive 

O (n + log n )
THETA(n)

// --------------------------------------------------------------------------------------------------------
2.8.1 QuickSort Algorithm 

Partition(l,h)
{
  pivot = A[l];
  i = l; j = h; 
while(i<j)
{
  do 
  {
    i++; 
  } while(A[i]<=pivot);
  do 
  {
    j++;
  } while(A[j]>pivot);
  if(i<j);
    swap(A[i],[j]);
}
swap(A[l],A[j]);
return j; 
}

QuickSort(l,h)
{
  if(l<h)
  {
    j = partition(l,h);
    QuickSort(l,j);
    QuickSort(j+1,h);
  }
}

// --------------------------------------------------------------------------------------------------------
2.8.2 QuickSort Analysis 

QuickSort(l,h)
{
  if(l<h)
  {
    j = partition(l,h);
    QuickSort(l,j);
    QuickSort(j+1,h);
  }
}

1 ...   ...    ... 15 
1 ...   789    ... 15                 
                  1,15                        ----- n   | n / 2 / 2 / 2 = 1 
               /   8   \                                | 
            1,7          9,15                 ----- n   | n / 2(to power of k) = 1 
          / 4 \            / 12 \                       |
        1,3    5,7       9,11    13,15        ----- n   | n = 2(to power of k)
      / 2 \   / 4 \      / 10 \    / 14 \               |
    1,1  3,3  5,5 7,7   9,9 11,11 13,13  15,15          | k = log n 
O(n log n)

Best Case: O(n log n)

Worst Case: ? 
2 4 8 10 16 18 17 

n ----- 1,7 
           \
n-1 ----- 2,7
             \
n-2 -----   3,7 
               \ 
              4,7
                 \ 
                5,7
                   \
                  6,7
                     \
                    7,7
n(n+1) / 2 
O(n(to power of 2))

Worst Case: O(n(to power of 2))

1. select middle element as pivot 
2. select random elemenet as pivot 

// --------------------------------------------------------------------------------------------------------
2.9 Strassens Matrix Multiplication 

{a11  a12}    {b11  b12}       {c11  c12}
{a21  a22}  * {b21  b22} = c = {c21  c22}

c11 = a11 * b11 + a12 * b21 
c12 = a12 * b12 + a12 * b22 
c21 = a22 * b11 + a22 * b21 
c22 = a21 * b12 + a22 * b22

a = [a11]   b = [b11]
c = [a11 * b11]

for(i=0; i<n; i++)
   {
    for(i=0; j<n; j++)
       {
        c[i,j] = 0;
        for(k=0; k<n; k++)
        {
          c[i,j]+=A[i,k]*B[k,j];
        }
       }
   }
O(n(to power of 3))

a11   a12 | a13   a14      Algorithm MM(A,B,n)
   a11    |    a12         {
a21   a22 | a23   a24          if(n <= 2)
----------|-----------         {
a31   a32 | a33   a34           c = 4 formulas
   a21    |    a22              ... 
a41   a42 | a43   a44          }
                             else
                             {
                              mid ... n/2 
                              MM(a11,b11,n/2)+MM(a12,b21,n/2)
                              MM(a11,b12,n/2)+MM(a12,b22,n/2)
                              MM(a21,b11,n/2)+MM(a22,b21,n/2)
                              MM(a21,b12,n/2)+MM(a22,b22,n/2)
                             }
                            }
              
c11 = a11 * b11 + a12 * b21 
c12 = a11 * b12 + a12 * b22 
c21 = a21 * b11 + a22 * b21 
c22 = a21 * b21 + a22 * b22 

T(n) = { 1                               n <= 2 }
       { 8T(n/2) + n(to power of 2)         n>2 }
a = 8 
b = 2 
f(n) = n(to power of 2)
log b a = log 8 = 3 
n(to power of k) = n(to power of 2)
THETA(n(to power of 3))

--------------------------| 
P = (a11 + a21)(b11 + b22)|
Q = (a21 + a22) b11       |             c11 = a11 * b11 + a12 * b21 
R = a11 (b12 - b22)       |             c12 = a11 * b12 + a12 * b22 
S = a22(b21 - b11)        |             c21 = a21 * b11 + a22 * b21 
T = (a11 + a12) b22       |             c22 = a21 * b21 + a22 * b22 
U = (a21 - a11)(b11 + b12)|
V = (a12 - a22)(b21 + b22)|
--------------------------|
c11 = P + S - T + V 
c12 = R + T 
c21 = Q + S   
c22 = P + R - Q + U 

T(n) = { 1                              n <= 2 }
       { 7T(n/2) + n(to power of 2)     n > 2) } 
log 7 = 2 * 81       k = 2 
O(n(to power of log 7)) = O(n(to power of 2*81))

// --------------------------------------------------------------------------------------------------------
3. Greedy Method 
      12hr
P: A -----> B 
  /  |  \  \  \ 
  S1 S2 S3 S4 S5 
            \  / 
            Feasable Solutions 
          1. Optimal Solution 
          Optimalization of P: 

1. Greedy Method 
2. Dynamic Programming 
3. Branch and Bound = optimalization problems 

Algorithm Greedy(a,n)         n = 5 
{                             a = a1 a2 a3 a4 a5 
  for i = 1 to n do 
  {
    x = Select(a); 
    if Feasible(x) then
      Solution = Solution + x; 
  }
}

// --------------------------------------------------------------------------------------------------------
3.1 Knapsack Problem - Greedy method 
n = 7 
m = 15 

Objets: o  1  2  3  4  5  6  7 
pisfits: P 10 5  15 7  6  18 3 
weights: w 2  3  5  7  1  4  1 
P/w        5 1.3 3  1  6 4.5 3
           | 2/3 |  O  |  |  | 
x          x1 x2 x3 x4 x5 x6 x7 

O <= x <= 1 

------| 15 - 1 = 14 
      | 14 - 2 = 12 
15kg  | 12 - 4 = 8 
------| 8 - 5 = 3 
        3 - 1 = 2 

x; w; = 1 * 2 + 2/3 * 3 + 1 * 5 + 0 * 7 + 1* 1 + 1 * 4 + 1 * 1 + 2+2 + 5  + 0 + 1 + 4 + 1 = 15 
x; P; = 1*10 + 2/3 * 5 + 1 * 15 + 1 * 6 + 1 * 18 + 1*3
= 10 + 2 + 1 * 3 + 15 + 6 +18 + 3 = 54 * 6 

constant 
x; w; <= m 
objective
max x; p; 

// --------------------------------------------------------------------------------------------------------
3.2 Job Sequencing with Deadlines - Greedy method 
n = 5 
Jobs      = J1  J2  J3  J4  J5 
profits   = 20  15  10   5   1 
deadlines =  2   2   1   3   3 

20 + 15 + 5 = 40 
{J1, J2, J4 }

  J2    J1    J4
0 --- 1 --- 2 --- 3 
9     10    11    12 

J1 -> J2 -> J4 
J2 -> Ji -> J4 

| Job considered | slot asign | solution | profit | 
|       -        |      -     |     -    |    -   | 
|----------------|------------|----------|--------|
|       J1       |    [1,2]   |    J1    |   20   | 
|----------------|------------|----------|--------| 
|       J2       | [0,1] [1,2]|  J1,J2   | 20 + 15| 
|----------------|------------|----------|--------| 
|       J3 x     | [0,1] [1,2]|  J1,J2   | 20 + 15|
|----------------|------------|----------|--------| 
|       J4       |[0,1][1,2][2,3]|J1,J2,J3|20+15+5|
|----------------|------------|----------|--------| 
|       J5       |    ...     |    ...   |   40   | 
|----------------|------------|----------|--------| 

  J4    J3    J1    J2
0 --- 1 --- 2 --- 3 --- 4 
  20    25    35    30   = 110 

// --------------------------------------------------------------------------------------------------------
3.3 Optimal Merge Pattern - Greedy Method 

A  B  C 
3  5  3 
8  9  5 
12 11 8 
20 16 9
      11
      12  m n  THETA(m+n)
      16  4 4      8 
      20  

List  = A B C D 
sizes = 6 5 2 3 

A  B  C  D                       A  B  C  D 
6  5  2  3                       6  5  2  3 
\  /  /  /                       \  /  \  / 
 11  /  /                         11     5
  \ /  /                            \   / 
   13 /    11 + 13 + 16 = 40          16      11 + 5 + 16 = 32 
    \/
     16 

A  B  C  D 
6  5  2  3 
\  \  \  /
 \  \   5 
  \  \  / 
   \  10
    \ /
     16        16 + 10 + 5 = 31 


lists --> x1 x2 x3 x4 x5 
sizes --> 20 30 10  5 30 

            95
           /  \ 
          35   \            15 + 35 + 95 + 60 = 205 
         / \    \           3 * 5 + 3 * 10 + 2 * 20 + 2 * 30 + 2 * 30 = 205
        15  \    60         d; * x; 
       / \   \   / \ 
       5 10  20  30 30
       x4 x3 x1  x2 x5 

// --------------------------------------------------------------------------------------------------------
3.4 Huffman Coding - Greedy method 

message --> BCCABBDDAECCBBAEDDCC
length - 2.0 
ASCII -- 8 bit       8 * 20 = 160 bits 

A   65   01000001 
B   66   01000010 
C   67   ... 
D   68   ... 
E   69   ... 

character | count/frequency | code           20 * 3 = 60 bits 
    A     |   3   3/20      | 000            5*8bit     5*3
    B     |   5   5/20      | 001            characters codes
    C     |   6   6/20      | 010            40 + 15 = 55 
    D     |   4   4/20      | 011            msg ---- 60 bits 
    E     |   2   2/20      | 100            table --- 55 bits 
                                             = 115 bits 
--------------------
            20
           /  \ 
          9    \             
         / \    \           
        5   \    11         
       / \   \   / \ 
       2  3  4  5   6
       E  A  D  B   C  



character | count      | code  |          
    A     |   3        | 001   | 3 * 3 = 9          
    B     |   5        | 10    | 5 * 2 = 10        
    C     |   6        | 11    | 6 * 2 = 12          
    D     |   4        | 01    | 4 * 2 = 8          
    E     |   2        | 000   | 2 * 3 = 6 

5 * 8 bit = 40 bit + 12 bit + 45 bit 
msg --- 45 bit 
tree/table -- 52 bits 
= 97 bits 

d; * f; 
3 * 2 + 3 * 3 + 2 * 4 + 2 * 5 + 2 * 6 = 45 bit 

// --------------------------------------------------------------------------------------------------------
3.5 Prims and Kuskals Algorithms - Greedy method 

     1                           1 
    / \                         /
   2   6                       2   6
   |   |                       |   | 
   3   5                       3   5
    \ /                         \ /
     4                           4
                                                   S                                                      
 = (V, E)                         |V| = n = 6      S(V E)
v = {1,2,3,4,5,6}                 |v| = -1 = 5     V = V 
E = {(1,2),(2,3),(3,4)...}                         |E| = |V| -1

     1                           1 
    / \                         / \
   2   6                       2   6
   |   |                       |   | 
   3---5                       3---5
    \ /                           /
     4                           4
|E| = 6                    7c5 = 6 

     5
  1 ----- 2 
  |     / |
4 |  2/   | 3 
  | /     | 
  4 ----- 3 
      6

    5
1 ----- 2       1       2      1    2
        |       |       |      |   /| 
        | 3   4 |       | 3  4 | 2/ | 3
        |       |       |      | /  |
4 ----- 3       4 ----- 3      4    3
    6               6 
cost = 14         cost = 13       cost = 9 

------ 
Prisms 

       1
  10  /
     6      7 
25   |       \  14 
     5        2 
22    \      /  16
       4 -- 3   
         12
cost = 99 

|E|
|V| - 1 
THETA(|V| |E|)
THETA(n*e) = THETA(n(to power of 2))

// --------------------------------------------------------------------------------------------------------
3.6 Dijkstra Algorithm - Single Source Shortest Path - Greedy method 
        7
    2 ----- 4 
2 / |       | \  1 
  1 |1     2| 6
4 \ |       | /  5 
    3 ----- 5 
        3 

   2    2   4    6 
1 ----- 2 ----- 3
        u       v 
        2 + 4 < undefined 

Relaxation 
if(d[u]+c(u,v)<d[v])
    d[v]=d[u]+c(u,v)

    2   7   8
    2 ----- 4 
2 / |       | \  1 
5 1 |1     2| 6 9
4 \ |       | /  5 
    3 ----- 5 
    3   3   6

v | d[v]
2 | 2
3 | 3 
4 | 8 
5 | 6                  n * n = n**2 
6 | 9      n = |V|     THETA = (|V|**2)
                       THETA = (n**2) 

stailing vertex 1 
---------| 
selected | 
vertex   |  2    3    4    5   6 
---------|----|----|----|----|----|
     | 4 | 50 | 45 | 10*| ♾  | ♾ |
     | 5 | 50 | 45 | 10*| 25*| ♾ |            3
     | 2 | 45*| 45 | 10*| 25*| ♾ |         1 --- 2 
     | 3 | 45*| 45*| 10*| 25*| ♾ |      4   \   /   5 
     | 6 | 45*| 45*| 10*| 25*| ♾*|            3

               45
      |-----------------|
      | 50              |
  |-> 1 -> 2 ------> 3<-|
  |       / |--|    / /
10|   15 /     | 35/ / 
  |     /    20|  / /30 
  |    /       | / /
    4 --------> 5 <------ 6 
          15           3 

// --------------------------------------------------------------------------------------------------------
4. Principle of Optimality - Dynamic Programming Introduction 

1. Greedy Method 
2. Dynamic Programming = principle of optimality 

fib(n) = { O                  if n = 0 }
         { 1                  if n = 1 }
         { fib(n-2) + fib(n-1) if n > 1}

int fib(int n)
{
  if(n <= 1)
    return n; 
    return fib(n-2) + fib(n-1); 
}

0, 1, 1, 2, 3, 5, 8, 13
0  1  2  3  4  5  6  7  ... 

             fib(5)
             /     \
        fib(3)      fib(4)
        /     \      /    \ 
   fib(1)  fib(2)  fib(2)   fib(3)
          /  \      /  \       /   \ 
    fib(0) fib(1)  /  fib(1) fib(1) fib(2)          T(n) = 2T(n-1) + 1 
                  fib(0)             /  \              O(n**2)
                                  f(0)   f(1)      

F -1 -1 -1 -1 -1 -1            fib(n+1) calls 
   0  1  2  3  4  5                   O(n)

F  0  1  1  2  3  5  
   0  1  2  3  4  5  

// --------------------------------------------------------------------------------------------------------
4.2 All Pairs Shortes Path (Floyd-Warshall) - Dynamic Programming 
                                        8 
                                   |<-------|
                                   |   3    |
        1 2 3 4                |-- 1 -----> 2 
    1 { 0 3 ♾ 7 }              |   | \      |
A = 2 { 8 0 2 ♾ }              |  2|   \5   | 2
    3 { 5 ♾ 0 1 }              |   |     \  | 
    4 { 2 ♾ ♾ 0 }              |->4 <----- 3 
                                        1 
  / 2     / 1
1 - 3   3 - 2 
  \ 4     \ 4
                  n**2 * n = O(n**3)
  / 1     / 1 
2 - 3   4 - 2  
  \ 4     \ 3

        1 2 3 4                 
    1 { 0 3 ♾ 7 }              
A1= 2 { 8 0 2 15 }             
    3 { 5 8 0 1 }              
    4 { 2 8 ♾ 0 } 

A1[2,3]   A1[2,1] + A1[1,3]
   2    <    8    +   ♾
a1[2,4]   A1[2,1] + A1[1,4]
   ♾   >     8    +    7 
a1[3,2]   A1[3,1] + A1[1,2]
   ♾    >    5    +    3 

        1 2 3 4                 
    1 { 0 3 5 7  }              
A2= 2 { 8 0 2 15 }             
    3 {   8 0    }              
    4 {   8    0 } 

A2[1,3]    A2[1,2] + A2[2,3]
   ♾   >   3     +    2 
A2[1,4]    A2[1,2] + A2[2,4]
   7   <   3     +    15 

        1 2 3 4                 
    1 { 0 3 5    }              
A3= 2 {   0 2    }             
    3 { 5 8 0  1 }              
    4 {     7  0 } 
  
A3[1,2]   A3[1,3] + A3[3,2]
    3   <    5    +    8

        1 2 3 4                 
    1 { 0 3 5 6  }              
A4= 2 { 5 0 2 3  }             
    3 { 3 6 0 1  }              
    4 { 2 5 7 0  } 

Ak[i,j]=min{Ak-1[i,j],Ak-1[j,k] + Ak-1[k,j]}

for(k=1; k<=n; k++)
{
  for(i=1; i<=n; i++)
  {
    for(j=i; j<n; j++)
    {
      A[i,j]=min{A[i,j],A[i,k] + A[k,j]}
    }
  }
}

// --------------------------------------------------------------------------------------------------------
4.3 Matrix Chain Multiplication - Dynamic Programming 

A1  *  A2  *  A3  *  A4 
5*4    4*6   6*2    2*7

A   *   B   =   C 
5*4    4*3     5*3=15*4 
   B * A       5*3*4 = 60 
  4*5<->5*4

((A1 * A2) * A3) * A4         O                  O
(A1 * A2) * (A3 * A4)        / \                / \
T(n) = 2nCn / n+1           O   O              O   A4
T(3) = 5                   / \  / \           / \
                          A1 A2 A3 A4        O   A3
                                            / \
                                           A1 A2 
m    1    2    3    4                                        
  |----|----|----|----|
1 |  0 | 120| 88 | 158|  
  |----|----|----|----|
2 |    |  0 | 48 | 104| 
  |----|----|----|----|
3 |    |    |  0 | 89 |
  |----|----|----|----|
4 |    |    |    |  0 | 
  |----|----|----|----| 

min { A1 * (A2 * A3) }           { (A1 * A2) * A3 } 
    { 5*4   4*6  6*2 }           {  5*4  4*6  6*2 }
m[1,1] + m[2,3] + 5 * 4 * 2      m[1,2] + m[3,3] + 5 *6 * 2 
   O   +   48   +  40            120    +    0   + 60 
        = 88                           = 180

S    1    2    3    4                                        
  |----|----|----|----|
1 |    |  1 |  1 |  1 |  
  |----|----|----|----|
2 |    |    |  2 |  3 | 
  |----|----|----|----|
3 |    |    |    |  3 |
  |----|----|----|----|
4 |    |    |    |    | 
  |----|----|----|----| 

m[2,4] = 104 

A2 * (A3 * A4)                    (A2 * A3) * A4 
4*6   6*2  2*7                    4*6   6*2  2*7
m[2,2] + m[3,4] + 4 * 6 * 7       m[2,3] + m[4,4] + 4 * 2 * 7 
   O   +   84   +    168            48   +    0   +   58 
         = 252                             = 104 

A1  *  A2  *  A3  *  A4 
5*4    4*6   6*2    2*7
d0   d1    d2    d3   d4 

m[1,4] = min{m[1,1]+m[2,4]+5*4*7   m[1,2]+m[3,4]+5*6*7}
            {   0     104 + 140      120 + 84   + 210 }
                    m[1,3] + m[4,4] + 5 * 2 * 7 
                      80   +    0   +   70 
m[i,j] = min{m[i,k] + m[k+1,j] + di-1 * dk * dj}

(A1 * A2 * A3)(A4)
((A1) * (A2 * A3)) * (A4)
         O  
         / \
        O   \
       / \   \ 
      /   O   \                      n(n-1) / 2 = n**2 * n = n**3 
     /    /\   \                     THETA(n**3)
    A1   A2 A3  A4

// --------------------------------------------------------------------------------------------------------
4.3.1 Matrix Chain Multiplication (Program) - Dynamic Programming 

A1  *  A2  *  A3  *  A4 
5*4    4*6   6*2    2*7

|---|---|---|---|---|---|
| P | 5 | 4 | 6 | 2 | 7 |
                                 n = 5
i  j    i  j    i  j             d < 5 - 1 
1  2    1  3    1  4             d < 4 
2  3    2  4    1  4             1 - 3 
3  4
d = 1   d = 2   d = 3 

A1   A2     A2   A3
5*4 4*6     4*6 6*2 
5*4*6          48

k = 1 A1 * (A2 * A3)
k = 2 (A1 - A2) * A3 

                   0    +    48   +    40 
k = 1 m[1][3] = m[1][1] + m[2][3] + 5 * 4 * 2 
                  120   +    0    +    60 
k = 2 m[1][3] = m[1][2] + m[3][3] + 5 * 6 * 2 

                    0   +    84   +   168 
k = 2 m[2][4] = m[2][2] + m[3][4] + 4 * 6 * 7 
                   48   +    0    +    56
k = 3 m[2][4] = m[2][3] + m[4][4] + 4 * 2 * 7 

k = 1       { 0 + 104 + 5 * 4 * 7 = 104 + 140   }
k = 2   min { 120 + 84 + 5 * 6 * 7 = 204 + 210  }
k = 3       { 88 + 0 + 5 * 2 * 7 = 88 * 70      }

      O  
    /   \
  1-3    4-4
 /  \       A4                (A1(A2 * A3)) * A4
1-1  2-3
A1    / \
    2-2  3-3
    A2   A3 
main()
{
  int n = 5;
  int P[] = {5,4,6,2,7};
  int m[5][5] = {0};
  int S[5][5] = {0}; 
  int j, min, q; 
  for(int d = 1; d< n - 1; d++)
  {
    for(int i = 1; i < n - d; i++)
    {
      j = i + d; 
      min = 32767;
      for(int k = 1; K <= j - i, k++)
      {
        q = m[i][k] + m[k+1][j] + P[i-j] * P[k] * P[j];
        if(q < min)
      }
    }
    m[i][j] = min; 
  }
  cout << m[1][n-1];
}

m    1    2    3    4           S    0    1    2    3    4                                 
  |----|----|----|----|----|      |----|----|----|----|----| 
1 |  0 |  0 |  0 |  0 |  0 |    0 |  0 |  0 |  0 |  0 |  0 | 
  |----|----|----|----|----|      |----|----|----|----|----| 
2 |  0 |  0 | 120| 88 | 158|    1 |  0 |  0 |  1 |  1 |  3 | 
  |----|----|----|----|----|      |----|----|----|----|----| 
3 |  0 |    |  0 |  3 | 104|    2 |  0 |    |  0 |  2 |  3 | 
  |----|----|----|----|----|      |----|----|----|----|----| 
4 |  0 |    |    |  0 | 84 |    3 |  0 |    |    |  0 |  3 | 
  |----|----|----|----|----|      |----|----|----|----|----| 
4 |  0 |    |    |    |  0 |    4 |  0 |    |    |    |  0 |  
  |----|----|----|----|----|      |----|----|----|----|----|

// --------------------------------------------------------------------------------------------------------

